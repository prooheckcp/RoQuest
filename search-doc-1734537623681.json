{"searchDocs":[{"title":"PlayerQuestData","type":0,"sectionRef":"#","url":"/RoQuest/api/PlayerQuestData","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"PlayerQuestData","url":"/RoQuest/api/PlayerQuestData#properties","content":" ","version":null,"tagName":"h2"},{"title":"InProgress​","type":1,"pageTitle":"PlayerQuestData","url":"/RoQuest/api/PlayerQuestData#InProgress","content":"&lt;/&gt; PlayerQuestData.InProgress: {[string]: QuestProgress} Contains all the quests in progress by the Player  ","version":null,"tagName":"h3"},{"title":"Completed​","type":1,"pageTitle":"PlayerQuestData","url":"/RoQuest/api/PlayerQuestData#Completed","content":"&lt;/&gt; PlayerQuestData.Completed: {[string]: QuestProgress} Contains all the completed quests by the Player  ","version":null,"tagName":"h3"},{"title":"Delivered​","type":1,"pageTitle":"PlayerQuestData","url":"/RoQuest/api/PlayerQuestData#Delivered","content":"&lt;/&gt; PlayerQuestData.Delivered: {[string]: QuestProgress} Contains all the delivered quests by the Player ","version":null,"tagName":"h3"},{"title":"ObjectiveInfo","type":0,"sectionRef":"#","url":"/RoQuest/api/ObjectiveInfo","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"ObjectiveInfo","url":"/RoQuest/api/ObjectiveInfo#properties","content":" ","version":null,"tagName":"h2"},{"title":"ObjectiveId​","type":1,"pageTitle":"ObjectiveInfo","url":"/RoQuest/api/ObjectiveInfo#ObjectiveId","content":"&lt;/&gt; ObjectiveInfo.ObjectiveId: string This is an ID to represent the objective. Should be used to identify the objective in the code. When we tell the server that player did X objective this is how it will determine if it should add or not to this objective.  ","version":null,"tagName":"h3"},{"title":"Name​","type":1,"pageTitle":"ObjectiveInfo","url":"/RoQuest/api/ObjectiveInfo#Name","content":"&lt;/&gt; ObjectiveInfo.Name: string The name of our objective. Can be used by the player or server to display the name of the objective that the player must complete  ","version":null,"tagName":"h3"},{"title":"Description​","type":1,"pageTitle":"ObjectiveInfo","url":"/RoQuest/api/ObjectiveInfo#Description","content":"&lt;/&gt; ObjectiveInfo.Description: string A more detailed description of our objective. Can be used by the developer to display the description ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"ObjectiveInfo","url":"/RoQuest/api/ObjectiveInfo#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"ObjectiveInfo","url":"/RoQuest/api/ObjectiveInfo#new","content":"&lt;/&gt; ObjectiveInfo.new(properties: {[string]: any}) → ObjectiveInfo Constructor for ObjectiveInfo local appleQuest = ObjectiveInfo.new { ObjectiveId = &quot;CollectApples&quot;, Name = &quot;Collect Apples&quot;, Description = &quot;Collect %s apples&quot;, }   ","version":null,"tagName":"h3"},{"title":"NewObjective​","type":1,"pageTitle":"ObjectiveInfo","url":"/RoQuest/api/ObjectiveInfo#NewObjective","content":"&lt;/&gt; ObjectiveInfo:NewObjective(target: number) → number Extends the Objective Info into a Quest Objective which is what we feed into our Quests local appleQuest = ObjectiveInfo.new { ObjectiveId = &quot;CollectApples&quot;, Name = &quot;Collect Apples&quot;, Description = &quot;Collect %s apples&quot;, } local objective1 = appleQuest:NewObjective(5) -- Created an objective to collect 5 apples local objective2 = appleQuest:NewObjective(3) -- Created an objective to collect 3 apples local objective3 = appleQuest:NewObjective(7) -- Created an objective to collect 7 apples  ","version":null,"tagName":"h3"},{"title":"QuestAcceptType","type":0,"sectionRef":"#","url":"/RoQuest/api/QuestAcceptType","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"QuestAcceptType","url":"/RoQuest/api/QuestAcceptType#types","content":" ","version":null,"tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"QuestAcceptType","url":"/RoQuest/api/QuestAcceptType#Status","content":"&lt;/&gt; interface Status { Automatic: &quot;Automatic&quot;-- The quest will automatically be accepted when the player meets the requirements Manual: &quot;Manual&quot;-- The quest will be accepted when the player manually accepts it }  ","version":null,"tagName":"h3"},{"title":"QuestDeliverType","type":0,"sectionRef":"#","url":"/RoQuest/api/QuestDeliverType","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"QuestDeliverType","url":"/RoQuest/api/QuestDeliverType#types","content":" ","version":null,"tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"QuestDeliverType","url":"/RoQuest/api/QuestDeliverType#Status","content":"&lt;/&gt; interface Status { Automatic: &quot;Automatic&quot;-- The quest will automatically be delivered when completed Manual: &quot;Manual&quot;-- It requires to be manually delivered by the developer }  ","version":null,"tagName":"h3"},{"title":"QuestObjective","type":0,"sectionRef":"#","url":"/RoQuest/api/QuestObjective","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"QuestObjective","url":"/RoQuest/api/QuestObjective#properties","content":" ","version":null,"tagName":"h2"},{"title":"ObjectiveInfo​","type":1,"pageTitle":"QuestObjective","url":"/RoQuest/api/QuestObjective#ObjectiveInfo","content":"&lt;/&gt; QuestObjective.ObjectiveInfo: ObjectiveInfo A reference to the ObjectiveInfo object that this QuestObjective is based on  ","version":null,"tagName":"h3"},{"title":"TargetProgress​","type":1,"pageTitle":"QuestObjective","url":"/RoQuest/api/QuestObjective#TargetProgress","content":"&lt;/&gt; QuestObjective.TargetProgress: number The target progress required for the player complete this objective  ","version":null,"tagName":"h3"},{"title":"Completed​","type":1,"pageTitle":"QuestObjective","url":"/RoQuest/api/QuestObjective#Completed","content":"&lt;/&gt; QuestObjective.Completed: Signal A Signal that fires whenever the quest objective is marked as completed local flowerQuest = ObjectiveInfo.new { ObjectiveId = &quot;CollectFlowers&quot;, Name = &quot;Collect Flowers&quot;, Description = &quot;Collect %s flowers&quot;, } local appleObjective1 = appleQuest:NewObjective(5) -- Created an objective to collect 5 apples appleObjective1.Completed:Connect(function() print(&quot;Objective 1 has been completed!&quot;) end)  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"QuestObjective","url":"/RoQuest/api/QuestObjective#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"QuestObjective","url":"/RoQuest/api/QuestObjective#new","content":"&lt;/&gt; QuestObjective.new(properties: {[string]: any}) → QuestObjective Constructor for QuestObjective QuestObjective.new { TargetProgress = 10, -- Creates a new objective with a target progress of 10 }   ","version":null,"tagName":"h3"},{"title":"Get​","type":1,"pageTitle":"QuestObjective","url":"/RoQuest/api/QuestObjective#Get","content":"&lt;/&gt; QuestObjective:Get() → number Gets the current target progress of our objective print(QuestObjective:Get()) -- 0 QuestObjective:Set(5) print(QuestObjective:Get()) -- 5   ","version":null,"tagName":"h3"},{"title":"GetTargetProgress​","type":1,"pageTitle":"QuestObjective","url":"/RoQuest/api/QuestObjective#GetTargetProgress","content":"&lt;/&gt; QuestObjective:GetTargetProgress() → number Gets the target to complete this objective local appleObjective1 = appleQuest:NewObjective(5) -- Created an objective to collect 5 apples print(appleObjective1:GetTargetProgress()) -- 5   ","version":null,"tagName":"h3"},{"title":"GetObjectiveId​","type":1,"pageTitle":"QuestObjective","url":"/RoQuest/api/QuestObjective#GetObjectiveId","content":"&lt;/&gt; QuestObjective:GetObjectiveId() → string Gets an id with the objective ID of the QuestObjective local flowerQuest = ObjectiveInfo.new { ObjectiveId = &quot;CollectFlowers&quot;, Name = &quot;Collect Flowers&quot;, Description = &quot;Collect %s flowers&quot;, } local appleObjective1 = appleQuest:NewObjective(5) -- Created an objective to collect 5 apples print(appleObjective1:GetObjectiveId()) -- &quot;CollectFlowers&quot;   ","version":null,"tagName":"h3"},{"title":"GetName​","type":1,"pageTitle":"QuestObjective","url":"/RoQuest/api/QuestObjective#GetName","content":"&lt;/&gt; QuestObjective:GetName() → string Gets an id with the objective ID of the QuestObjective local flowerQuest = ObjectiveInfo.new { ObjectiveId = &quot;CollectFlowers&quot;, Name = &quot;Collect Flowers&quot;, Description = &quot;Collect %s flowers&quot;, } local appleObjective1 = appleQuest:NewObjective(5) -- Created an objective to collect 5 apples print(appleObjective1:GetName()) -- &quot;Collect Flowers&quot;   ","version":null,"tagName":"h3"},{"title":"GetDescription​","type":1,"pageTitle":"QuestObjective","url":"/RoQuest/api/QuestObjective#GetDescription","content":"&lt;/&gt; QuestObjective:GetDescription() → string Gets an id with the objective ID of the QuestObjective local flowerQuest = ObjectiveInfo.new { ObjectiveId = &quot;CollectFlowers&quot;, Name = &quot;Collect Flowers&quot;, Description = &quot;Collect %s flowers&quot;, } local appleObjective1 = appleQuest:NewObjective(5) -- Created an objective to collect 5 apples print(appleObjective1:GetDescription()) -- &quot;Collect %s flowers&quot;   ","version":null,"tagName":"h3"},{"title":"Add​","type":1,"pageTitle":"QuestObjective","url":"/RoQuest/api/QuestObjective#Add","content":"&lt;/&gt; QuestObjective:Add(amount: number) → boolean Adds an amount to the current progress of the objective print(QuestObjective:Get()) -- 0 QuestObjective:Add(1) print(QuestObjective:Get()) -- 1   ","version":null,"tagName":"h3"},{"title":"Remove​","type":1,"pageTitle":"QuestObjective","url":"/RoQuest/api/QuestObjective#Remove","content":"&lt;/&gt; QuestObjective:Remove(amount: number) → boolean Removes an amount to the current progress of the objective print(QuestObjective:Get()) -- 1 QuestObjective:Remove(1) print(QuestObjective:Get()) -- 0   ","version":null,"tagName":"h3"},{"title":"Set​","type":1,"pageTitle":"QuestObjective","url":"/RoQuest/api/QuestObjective#Set","content":"&lt;/&gt; QuestObjective:Set(newAmount: number) → boolean Sets the current progress amount of our objective print(QuestObjective:Get()) -- 0 QuestObjective:Set(1) print(QuestObjective:Get()) -- 1 QuestObjective:Set(5) print(QuestObjective:Get()) -- 5   ","version":null,"tagName":"h3"},{"title":"IsCompleted​","type":1,"pageTitle":"QuestObjective","url":"/RoQuest/api/QuestObjective#IsCompleted","content":"&lt;/&gt; QuestObjective:IsCompleted() → boolean Checks if the quest has already been completed or not print(QuestObjective:IsCompleted()) -- false QuestObjective:Set(5) print(QuestObjective:IsCompleted()) -- true   ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"QuestObjective","url":"/RoQuest/api/QuestObjective#Destroy","content":"&lt;/&gt; QuestObjective:Destroy() → () Destroys the QuestObjective and clears up the object QuestObjective:Destroy()  ","version":null,"tagName":"h3"},{"title":"QuestObjectiveProgress","type":0,"sectionRef":"#","url":"/RoQuest/api/QuestObjectiveProgress","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"QuestObjectiveProgress","url":"/RoQuest/api/QuestObjectiveProgress#properties","content":" ","version":null,"tagName":"h2"},{"title":"CurrentProgress​","type":1,"pageTitle":"QuestObjectiveProgress","url":"/RoQuest/api/QuestObjectiveProgress#CurrentProgress","content":"&lt;/&gt; QuestObjectiveProgress.CurrentProgress: number Contains the data for the current progress of this objective  ","version":null,"tagName":"h3"},{"title":"Completed​","type":1,"pageTitle":"QuestObjectiveProgress","url":"/RoQuest/api/QuestObjectiveProgress#Completed","content":"&lt;/&gt; QuestObjectiveProgress.Completed: boolean A flat to determine is the objective is complete or not ","version":null,"tagName":"h3"},{"title":"QuestLifeCycle","type":0,"sectionRef":"#","url":"/RoQuest/api/QuestLifeCycle","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"QuestLifeCycle","url":"/RoQuest/api/QuestLifeCycle#properties","content":" ","version":null,"tagName":"h2"},{"title":"Name​","type":1,"pageTitle":"QuestLifeCycle","url":"/RoQuest/api/QuestLifeCycle#Name","content":"&lt;/&gt; QuestLifeCycle.Name: string The name of the lifecycle. This needs to be unique for each lifecycle  ","version":null,"tagName":"h3"},{"title":"Player​","type":1,"pageTitle":"QuestLifeCycle","url":"/RoQuest/api/QuestLifeCycle#Player","content":"&lt;/&gt; QuestLifeCycle.Player: Player  A reference to the player to which this lifecycle is associated  ","version":null,"tagName":"h3"},{"title":"Quest​","type":1,"pageTitle":"QuestLifeCycle","url":"/RoQuest/api/QuestLifeCycle#Quest","content":"&lt;/&gt; QuestLifeCycle.Quest: Quest A reference to the quest that this lifecycle is managing ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"QuestLifeCycle","url":"/RoQuest/api/QuestLifeCycle#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"QuestLifeCycle","url":"/RoQuest/api/QuestLifeCycle#new","content":"&lt;/&gt; QuestLifeCycle.new(properties: {[string]: any}) → Quest Constructor for Quest local appleQuest = QuestLifeCycle.new { Name = &quot;AppleQuest&quot;, }   ","version":null,"tagName":"h3"},{"title":"OnInit​","type":1,"pageTitle":"QuestLifeCycle","url":"/RoQuest/api/QuestLifeCycle#OnInit","content":"&lt;/&gt; QuestLifeCycle:OnInit() → () Called when the quest object gets created. If the player just joined the game and the quest is already in progress it will still call OnInit! INFO This is a virtual method. Meaning you can override it in your lifecycle  ","version":null,"tagName":"h3"},{"title":"OnStart​","type":1,"pageTitle":"QuestLifeCycle","url":"/RoQuest/api/QuestLifeCycle#OnStart","content":"&lt;/&gt; QuestLifeCycle:OnStart() → () Called when the player quest starts the quest INFO This is a virtual method. Meaning you can override it in your lifecycle  ","version":null,"tagName":"h3"},{"title":"OnComplete​","type":1,"pageTitle":"QuestLifeCycle","url":"/RoQuest/api/QuestLifeCycle#OnComplete","content":"&lt;/&gt; QuestLifeCycle:OnComplete() → () Called when the quest gets completed INFO This is a virtual method. Meaning you can override it in your lifecycle  ","version":null,"tagName":"h3"},{"title":"OnDeliver​","type":1,"pageTitle":"QuestLifeCycle","url":"/RoQuest/api/QuestLifeCycle#OnDeliver","content":"&lt;/&gt; QuestLifeCycle:OnDeliver() → () Called when the quest gets delivered. Doesn't get called if the player joined the game and the quest was already delivered INFO This is a virtual method. Meaning you can override it in your lifecycle  ","version":null,"tagName":"h3"},{"title":"OnObjectiveChange​","type":1,"pageTitle":"QuestLifeCycle","url":"/RoQuest/api/QuestLifeCycle#OnObjectiveChange","content":"&lt;/&gt; QuestLifeCycle:OnObjectiveChange( _objectiveId: string, _newAmount: number ) → () Called when an objective of the quest gets updated INFO This is a virtual method. Meaning you can override it in your lifecycle  ","version":null,"tagName":"h3"},{"title":"OnDestroy​","type":1,"pageTitle":"QuestLifeCycle","url":"/RoQuest/api/QuestLifeCycle#OnDestroy","content":"&lt;/&gt; QuestLifeCycle:OnDestroy() → () Called when the quest object gets destroyed. This happens when the player leaves the game or the quest gets removed INFO This is a virtual method. Meaning you can override it in your lifecycle ","version":null,"tagName":"h3"},{"title":"QuestProgress","type":0,"sectionRef":"#","url":"/RoQuest/api/QuestProgress","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"QuestProgress","url":"/RoQuest/api/QuestProgress#properties","content":" ","version":null,"tagName":"h2"},{"title":"QuestObjectiveProgresses​","type":1,"pageTitle":"QuestProgress","url":"/RoQuest/api/QuestProgress#QuestObjectiveProgresses","content":"&lt;/&gt; QuestProgress.QuestObjectiveProgresses: {[string]: QuestObjectiveProgress} A hashmap containing all the quest progress objectives of our quest  ","version":null,"tagName":"h3"},{"title":"QuestStatus​","type":1,"pageTitle":"QuestProgress","url":"/RoQuest/api/QuestProgress#QuestStatus","content":"&lt;/&gt; QuestProgress.QuestStatus: QuestStatus The current status of the quest. Wheter it is in progress, completed or delivered  ","version":null,"tagName":"h3"},{"title":"CompletedCount​","type":1,"pageTitle":"QuestProgress","url":"/RoQuest/api/QuestProgress#CompletedCount","content":"&lt;/&gt; QuestProgress.CompletedCount: number The amount of times this quest has been completed  ","version":null,"tagName":"h3"},{"title":"FirstCompletedTick​","type":1,"pageTitle":"QuestProgress","url":"/RoQuest/api/QuestProgress#FirstCompletedTick","content":"&lt;/&gt; QuestProgress.FirstCompletedTick: number The time date at which the quest was first completed  ","version":null,"tagName":"h3"},{"title":"LastCompletedTick​","type":1,"pageTitle":"QuestProgress","url":"/RoQuest/api/QuestProgress#LastCompletedTick","content":"&lt;/&gt; QuestProgress.LastCompletedTick: number The time date at which the quest was last completed ","version":null,"tagName":"h3"},{"title":"QuestRepeatableType","type":0,"sectionRef":"#","url":"/RoQuest/api/QuestRepeatableType","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"QuestRepeatableType","url":"/RoQuest/api/QuestRepeatableType#types","content":" ","version":null,"tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"QuestRepeatableType","url":"/RoQuest/api/QuestRepeatableType#Status","content":"&lt;/&gt; interface Status { NonRepeatable: &quot;NonRepeatable&quot;-- The quest can only be completed once Infinite: &quot;Infinite&quot;-- This means the quest can be repeated non-stop without any delay Daily: &quot;Daily&quot;-- Quest can be completed everyday Weekly: &quot;Weekly&quot;-- Quest can be completed weekly Custom: &quot;Custom&quot;-- Quest can only be completed when the developer sets it to be }  ","version":null,"tagName":"h3"},{"title":"QuestStatus","type":0,"sectionRef":"#","url":"/RoQuest/api/QuestStatus","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"QuestStatus","url":"/RoQuest/api/QuestStatus#types","content":" ","version":null,"tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"QuestStatus","url":"/RoQuest/api/QuestStatus#Status","content":"&lt;/&gt; interface Status { NotStarted: &quot;NotStarted&quot;-- The quest hasn't been initiated by the player InProgress: &quot;InProgress&quot;-- The quest is still in progress Completed: &quot;Completed&quot;-- The quest objectives have been fullfilled and the quest is now completed Delivered: &quot;Delivered&quot;-- Means the quest has been delivered and closed }  ","version":null,"tagName":"h3"},{"title":"Quest","type":0,"sectionRef":"#","url":"/RoQuest/api/Quest","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#properties","content":" ","version":null,"tagName":"h2"},{"title":"OnQuestObjectiveCompleted​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#OnQuestObjectiveCompleted","content":"&lt;/&gt; Quest.OnQuestObjectiveCompleted: Signal Called whenever a quest objective gets completed quest.OnQuestObjectiveCompleted:Connect(function(objectiveId: string) print(&quot;Completed Objective: &quot; .. objectiveId) end)   ","version":null,"tagName":"h3"},{"title":"OnQuestObjectiveChanged​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#OnQuestObjectiveChanged","content":"&lt;/&gt; Quest.OnQuestObjectiveChanged: Signal Called whenever one of the quests objective changes the value quest.OnQuestObjectiveChanged:Connect(function(objectiveId: string, newAmount: number) print(&quot;Objective &quot; .. objectiveId .. &quot; has changed to &quot; .. newAmount) end)   ","version":null,"tagName":"h3"},{"title":"OnQuestCompleted​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#OnQuestCompleted","content":"&lt;/&gt; Quest.OnQuestCompleted: Signal Called when the quest gets completed quest.OnQuestCompleted:Connect(function() print(&quot;The quest got completed!&quot;) end)   ","version":null,"tagName":"h3"},{"title":"OnQuestDelivered​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#OnQuestDelivered","content":"&lt;/&gt; Quest.OnQuestDelivered: Signal Called when the quest gets delivered quest.OnQuestDelivered:Connect(function() print(&quot;The quest got delivered!&quot;) end)   ","version":null,"tagName":"h3"},{"title":"OnQuestCanceled​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#OnQuestCanceled","content":"&lt;/&gt; Quest.OnQuestCanceled: Signal Called when the quest gets cancelled quest.OnQuestCanceled:Connect() print(&quot;The quest got cancelled!&quot;) end)   ","version":null,"tagName":"h3"},{"title":"Name​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#Name","content":"&lt;/&gt; Quest.Name: string The name of the quest  ","version":null,"tagName":"h3"},{"title":"Description​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#Description","content":"&lt;/&gt; Quest.Description: string The description of the quest  ","version":null,"tagName":"h3"},{"title":"Disabled​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#Disabled","content":"&lt;/&gt; Quest.Disabled: boolean If the quest is disabled or not. If the quest is disabled it will be ignored when loaded into the system  ","version":null,"tagName":"h3"},{"title":"Name​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#Name","content":"&lt;/&gt; Quest.Name: string The quest ID. This must be a unique identifier for the quest  ","version":null,"tagName":"h3"},{"title":"QuestAcceptType​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#QuestAcceptType","content":"&lt;/&gt; Quest.QuestAcceptType: QuestAcceptType The type of the quest accepting system. This can be either automatic or manual  ","version":null,"tagName":"h3"},{"title":"QuestDeliverType​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#QuestDeliverType","content":"&lt;/&gt; Quest.QuestDeliverType: QuestDeliverType The type of the quest delivering system. This can be either automatic or manual  ","version":null,"tagName":"h3"},{"title":"QuestRepeatableType​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#QuestRepeatableType","content":"&lt;/&gt; Quest.QuestRepeatableType: QuestRepeatableType How many times can this quest be repeated  ","version":null,"tagName":"h3"},{"title":"QuestStart​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#QuestStart","content":"&lt;/&gt; Quest.QuestStart: number UTC time to define when the quest should become available (specially useful for event quests)  ","version":null,"tagName":"h3"},{"title":"QuestEnd​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#QuestEnd","content":"&lt;/&gt; Quest.QuestEnd: number UTC time to define when the quest should no longer be available (specially useful for event quests)  ","version":null,"tagName":"h3"},{"title":"RequiredQuests​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#RequiredQuests","content":"&lt;/&gt; Quest.RequiredQuests: {string} This is an array with all the required quest IDs in order for this quest to become available  ","version":null,"tagName":"h3"},{"title":"LifeCycles​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#LifeCycles","content":"&lt;/&gt; Quest.LifeCycles: {string} This is an array with all the LifeCycles names that will manage this quest's behavior  ","version":null,"tagName":"h3"},{"title":"QuestObjectives​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#QuestObjectives","content":"&lt;/&gt; Quest.QuestObjectives: {QuestObjective} An array with all the objectives required to complete this quest ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#new","content":"&lt;/&gt; Quest.new(properties: {[string]: any}) → Quest Constructor for Quest local appleQuest = ObjectiveInfo.new { ObjectiveId = &quot;CollectApples&quot;, Name = &quot;Collect Apples&quot;, Description = &quot;Collect %s apples&quot;, } local quest = Quest.new { Name = &quot;Collect Apples&quot;, Description = &quot;Collect %s apples&quot;, QuestId = &quot;AppleCollection&quot;, QuestAcceptType = QuestAcceptType.Automatic, QuestDeliverType = QuestDeliverType.Automatic, QuestRepeatableType = QuestRepeatableType.NonRepeatable, QuestStart = 0, QuestEnd = 0, RequiredQuests = {}, LifeCycles = {&quot;AppleQuest&quot;}, QuestObjectives = { appleQuest:NewObjective(5) }, }   ","version":null,"tagName":"h3"},{"title":"IsObjectiveCompleted​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#IsObjectiveCompleted","content":"&lt;/&gt; Quest:IsObjectiveCompleted(objectiveId: string) → boolean Checks if the objective with the given objectiveID has already been completed by the quest owner or not  ","version":null,"tagName":"h3"},{"title":"GetQuestStatus​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#GetQuestStatus","content":"&lt;/&gt; Quest:GetQuestStatus() → QuestStatus Gets the current status of the quest  ","version":null,"tagName":"h3"},{"title":"GetCompleteCount​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#GetCompleteCount","content":"&lt;/&gt; Quest:GetCompleteCount() → number Gets the amount of times that this quest has been completed. Will return 0 if it has never been completed  ","version":null,"tagName":"h3"},{"title":"GetFirstCompletedTick​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#GetFirstCompletedTick","content":"&lt;/&gt; Quest:GetFirstCompletedTick() → number Gets the first UTC time that this quest was completed  ","version":null,"tagName":"h3"},{"title":"GetLastCompletedTick​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#GetLastCompletedTick","content":"&lt;/&gt; Quest:GetLastCompletedTick() → number Gets the last UTC time at which this quest was completed  ","version":null,"tagName":"h3"},{"title":"AddObjective​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#AddObjective","content":"&lt;/&gt; Quest:AddObjective( objectiveId: string, amount: number ) → () Adds to the objective of the quest by the amount specified  ","version":null,"tagName":"h3"},{"title":"RemoveObjective​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#RemoveObjective","content":"&lt;/&gt; Quest:RemoveObjective( objectiveId: string, amount: number ) → () Removes to the objective by the amount specfiied  ","version":null,"tagName":"h3"},{"title":"GetTimeForAvailable​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#GetTimeForAvailable","content":"&lt;/&gt; Quest:GetTimeForAvailable() → number Gets how long until the quest becomes available. It will return 0 if it is already available  ","version":null,"tagName":"h3"},{"title":"GetTimeForUnavailable​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#GetTimeForUnavailable","content":"&lt;/&gt; Quest:GetTimeForUnavailable() → number Will return how long until the quest becomes unavailable. It will return 0 if it is already unavailable  ","version":null,"tagName":"h3"},{"title":"GetQuestStart​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#GetQuestStart","content":"&lt;/&gt; Quest:GetQuestStart() → number Gets the UTC time at which this quest should become available  ","version":null,"tagName":"h3"},{"title":"GetQuestEnd​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#GetQuestEnd","content":"&lt;/&gt; Quest:GetQuestEnd() → number Gets the UTC time at which this quest should become disabled and no longer be available  ","version":null,"tagName":"h3"},{"title":"SetObjective​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#SetObjective","content":"&lt;/&gt; Quest:SetObjective( objectiveId: string, newAmount: number ) → () Sets the quest objective to the given new value  ","version":null,"tagName":"h3"},{"title":"GetTimeSinceCompleted​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#GetTimeSinceCompleted","content":"&lt;/&gt; Quest:GetTimeSinceCompleted() → number Gets the time since the quest was completed  ","version":null,"tagName":"h3"},{"title":"GetObjective​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#GetObjective","content":"&lt;/&gt; Quest:GetObjective(objectiveId: number) → number Gets an objective value by its id  ","version":null,"tagName":"h3"},{"title":"GetTargetObjective​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#GetTargetObjective","content":"&lt;/&gt; Quest:GetTargetObjective(objectiveId: string) → number Gets the target objective by the id  ","version":null,"tagName":"h3"},{"title":"GetQuestObjectivesCount​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#GetQuestObjectivesCount","content":"&lt;/&gt; Quest:GetQuestObjectivesCount() → number Returns a number with the amount of objectives that exist within this quest  ","version":null,"tagName":"h3"},{"title":"GetQuestObjectivesCompletedCount​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#GetQuestObjectivesCompletedCount","content":"&lt;/&gt; Quest:GetQuestObjectivesCompletedCount() → number Returns a number with the amount of completed objectives that exist within this quest  ","version":null,"tagName":"h3"},{"title":"GetQuestObjectives​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#GetQuestObjectives","content":"&lt;/&gt; Quest:GetQuestObjectives() → {[string]: QuestObjective}-- The index stands for the questId while the value stands for the QuestObjective class Returns an array of quest objectives for this given quest  ","version":null,"tagName":"h3"},{"title":"GetQuestObjective​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#GetQuestObjective","content":"&lt;/&gt; Quest:GetQuestObjective(objectiveId: string) → QuestObjective? Gets the objective by its id  ","version":null,"tagName":"h3"},{"title":"Complete​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#Complete","content":"&lt;/&gt; Quest:Complete() → boolean Sets the quest to complete if possible  ","version":null,"tagName":"h3"},{"title":"Deliver​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#Deliver","content":"&lt;/&gt; Quest:Deliver() → boolean Sets the quest to delivered if possible  ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"Quest","url":"/RoQuest/api/Quest#Destroy","content":"&lt;/&gt; Quest:Destroy() → () Cleans up our class ","version":null,"tagName":"h3"},{"title":"Promise","type":0,"sectionRef":"#","url":"/RoQuest/api/Promise","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#types","content":" ","version":null,"tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#Status","content":"enum &lt;/&gt; interface Status { Started: &quot;Started&quot;-- The Promise is executing, and not settled yet. Resolved: &quot;Resolved&quot;-- The Promise finished successfully. Rejected: &quot;Rejected&quot;-- The Promise was rejected. Cancelled: &quot;Cancelled&quot;-- The Promise was cancelled before it finished. } An enum value used to represent the Promise's status. ","version":null,"tagName":"h3"},{"title":"Properties​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#properties","content":" ","version":null,"tagName":"h2"},{"title":"Status​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#Status","content":"This item is read only and cannot be modified. Read Only enums &lt;/&gt; Promise.Status: Status A table containing all members of the Status enum, e.g., Promise.Status.Resolved. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#new","content":"&lt;/&gt; Promise.new(executor: ( resolve: (...: any) → (), reject: (...: any) → (), onCancel: (abortHandler?: () → ()) → boolean ) → ()) → Promise Construct a new Promise that will be resolved or rejected with the given callbacks. If you resolve with a Promise, it will be chained onto. You can safely yield within the executor function and it will not block the creating thread. local myFunction() return Promise.new(function(resolve, reject, onCancel) wait(1) resolve(&quot;Hello world!&quot;) end) end myFunction():andThen(print) You do not need to use pcall within a Promise. Errors that occur during execution will be caught and turned into a rejection automatically. If error() is called with a table, that table will be the rejection value. Otherwise, string errors will be converted into Promise.Error(Promise.Error.Kind.ExecutionError) objects for tracking debug information. You may register an optional cancellation hook by using the onCancel argument: This should be used to abort any ongoing operations leading up to the promise being settled. Call the onCancel function with a function callback as its only argument to set a hook which will in turn be called when/if the promise is cancelled. onCancel returns true if the Promise was already cancelled when you called onCancel. Calling onCancel with no argument will not override a previously set cancellation hook, but it will still return true if the Promise is currently cancelled. You can set the cancellation hook at any time before resolving. When a promise is cancelled, calls to resolve or reject will be ignored, regardless of if you set a cancellation hook or not. CAUTION If the Promise is cancelled, the executor thread is closed with coroutine.close after the cancellation hook is called. You must perform any cleanup code in the cancellation hook: any time your executor yields, it may never resume.  ","version":null,"tagName":"h3"},{"title":"defer​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#defer","content":"&lt;/&gt; Promise.defer(executor: ( resolve: (...: any) → (), reject: (...: any) → (), onCancel: (abortHandler?: () → ()) → boolean ) → ()) → Promise The same as Promise.new, except execution begins after the next Heartbeat event. This is a spiritual replacement for spawn, but it does not suffer from the same issues as spawn. local function waitForChild(instance, childName, timeout) return Promise.defer(function(resolve, reject) local child = instance:WaitForChild(childName, timeout) ;(child and resolve or reject)(child) end) end   ","version":null,"tagName":"h3"},{"title":"resolve​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#resolve","content":"&lt;/&gt; Promise.resolve(...: any) → Promise&lt;...any&gt; Creates an immediately resolved Promise with the given value. -- Example using Promise.resolve to deliver cached values: function getSomething(name) if cache[name] then return Promise.resolve(cache[name]) else return Promise.new(function(resolve, reject) local thing = getTheThing() cache[name] = thing resolve(thing) end) end end   ","version":null,"tagName":"h3"},{"title":"reject​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#reject","content":"&lt;/&gt; Promise.reject(...: any) → Promise&lt;...any&gt; Creates an immediately rejected Promise with the given value. CAUTION Something needs to consume this rejection (i.e. :catch() it), otherwise it will emit an unhandled Promise rejection warning on the next frame. Thus, you should not create and store rejected Promises for later use. Only create them on-demand as needed.  ","version":null,"tagName":"h3"},{"title":"try​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#try","content":"&lt;/&gt; Promise.try( callback: (...: T...) → ...any, ...: T...-- Additional arguments passed to callback ) → Promise Begins a Promise chain, calling a function and returning a Promise resolving with its return value. If the function errors, the returned Promise will be rejected with the error. You can safely yield within the Promise.try callback. INFO Promise.try is similar to Promise.promisify, except the callback is invoked immediately instead of returning a new function. Promise.try(function() return math.random(1, 2) == 1 and &quot;ok&quot; or error(&quot;Oh an error!&quot;) end) :andThen(function(text) print(text) end) :catch(function(err) warn(&quot;Something went wrong&quot;) end)   ","version":null,"tagName":"h3"},{"title":"all​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#all","content":"&lt;/&gt; Promise.all(promises: {Promise&lt;T&gt;}) → Promise&lt;{T}&gt; Accepts an array of Promises and returns a new promise that: is resolved after all input promises resolve. is rejected if any input promises reject. INFO Only the first return value from each promise will be present in the resulting array. After any input Promise rejects, all other input Promises that are still pending will be cancelled if they have no other consumers. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.all(promises)   ","version":null,"tagName":"h3"},{"title":"fold​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#fold","content":"since v3.1.0 &lt;/&gt; Promise.fold( list: {T | Promise&lt;T&gt;}, reducer: ( accumulator: U, value: T, index: number ) → U | Promise&lt;U&gt;, initialValue: U ) → () Folds an array of values or promises into a single value. The array is traversed sequentially. The reducer function can return a promise or value directly. Each iteration receives the resolved value from the previous, and the first receives your defined initial value. The folding will stop at the first rejection encountered. local basket = {&quot;blueberry&quot;, &quot;melon&quot;, &quot;pear&quot;, &quot;melon&quot;} Promise.fold(basket, function(cost, fruit) if fruit == &quot;blueberry&quot; then return cost -- blueberries are free! else -- call a function that returns a promise with the fruit price return fetchPrice(fruit):andThen(function(fruitCost) return cost + fruitCost end) end end, 0)   ","version":null,"tagName":"h3"},{"title":"some​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#some","content":"&lt;/&gt; Promise.some( promises: {Promise&lt;T&gt;}, count: number ) → Promise&lt;{T}&gt; Accepts an array of Promises and returns a Promise that is resolved as soon as count Promises are resolved from the input array. The resolved array values are in the order that the Promises resolved in. When this Promise resolves, all other pending Promises are cancelled if they have no other consumers. count 0 results in an empty array. The resultant array will never have more than count elements. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.some(promises, 2) -- Only resolves with first 2 promises to resolve   ","version":null,"tagName":"h3"},{"title":"any​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#any","content":"&lt;/&gt; Promise.any(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Accepts an array of Promises and returns a Promise that is resolved as soon as any of the input Promises resolves. It will reject only if all input Promises reject. As soon as one Promises resolves, all other pending Promises are cancelled if they have no other consumers. Resolves directly with the value of the first resolved Promise. This is essentially [[Promise.some]] with 1 count, except the Promise resolves with the value directly instead of an array with one element. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.any(promises) -- Resolves with first value to resolve (only rejects if all 3 rejected)   ","version":null,"tagName":"h3"},{"title":"allSettled​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#allSettled","content":"&lt;/&gt; Promise.allSettled(promises: {Promise&lt;T&gt;}) → Promise&lt;{Status}&gt; Accepts an array of Promises and returns a new Promise that resolves with an array of in-place Statuses when all input Promises have settled. This is equivalent to mapping promise:finally over the array of Promises. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.allSettled(promises)   ","version":null,"tagName":"h3"},{"title":"race​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#race","content":"&lt;/&gt; Promise.race(promises: {Promise&lt;T&gt;}) → Promise&lt;T&gt; Accepts an array of Promises and returns a new promise that is resolved or rejected as soon as any Promise in the array resolves or rejects. WARNING If the first Promise to settle from the array settles with a rejection, the resulting Promise from race will reject. If you instead want to tolerate rejections, and only care about at least one Promise resolving, you should use Promise.any or Promise.some instead. All other Promises that don't win the race will be cancelled if they have no other consumers. local promises = { returnsAPromise(&quot;example 1&quot;), returnsAPromise(&quot;example 2&quot;), returnsAPromise(&quot;example 3&quot;), } return Promise.race(promises) -- Only returns 1st value to resolve or reject   ","version":null,"tagName":"h3"},{"title":"each​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#each","content":"since 3.0.0 &lt;/&gt; Promise.each( list: {T | Promise&lt;T&gt;}, predicate: ( value: T, index: number ) → U | Promise&lt;U&gt; ) → Promise&lt;{U}&gt; Iterates serially over the given an array of values, calling the predicate callback on each value before continuing. If the predicate returns a Promise, we wait for that Promise to resolve before moving on to the next item in the array. INFO Promise.each is similar to Promise.all, except the Promises are ran in order instead of all at once. But because Promises are eager, by the time they are created, they're already running. Thus, we need a way to defer creation of each Promise until a later time. The predicate function exists as a way for us to operate on our data instead of creating a new closure for each Promise. If you would prefer, you can pass in an array of functions, and in the predicate, call the function and return its return value. Promise.each({ &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot; }, function(value, index) return Promise.delay(1):andThen(function() print((&quot;%d) Got %s!&quot;):format(index, value)) end) end) --[[ (1 second passes) &gt; 1) Got foo! (1 second passes) &gt; 2) Got bar! (1 second passes) &gt; 3) Got baz! (1 second passes) &gt; 4) Got qux! ]] If the Promise a predicate returns rejects, the Promise from Promise.each is also rejected with the same value. If the array of values contains a Promise, when we get to that point in the list, we wait for the Promise to resolve before calling the predicate with the value. If a Promise in the array of values is already Rejected when Promise.each is called, Promise.each rejects with that value immediately (the predicate callback will never be called even once). If a Promise in the list is already Cancelled when Promise.each is called, Promise.each rejects with Promise.Error(Promise.Error.Kind.AlreadyCancelled). If a Promise in the array of values is Started at first, but later rejects, Promise.each will reject with that value and iteration will not continue once iteration encounters that value. Returns a Promise containing an array of the returned/resolved values from the predicate for each item in the array of values. If this Promise returned from Promise.each rejects or is cancelled for any reason, the following are true: Iteration will not continue. Any Promises within the array of values will now be cancelled if they have no other consumers. The Promise returned from the currently active predicate will be cancelled if it hasn't resolved yet.  ","version":null,"tagName":"h3"},{"title":"is​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#is","content":"&lt;/&gt; Promise.is(object: any) → boolean-- true if the given object is a Promise. Checks whether the given object is a Promise via duck typing. This only checks if the object is a table and has an andThen method.  ","version":null,"tagName":"h3"},{"title":"promisify​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#promisify","content":"&lt;/&gt; Promise.promisify(callback: (...: any) → ...any) → (...: any) → Promise Wraps a function that yields into one that returns a Promise. Any errors that occur while executing the function will be turned into rejections. INFO Promise.promisify is similar to Promise.try, except the callback is returned as a callable function instead of being invoked immediately. local sleep = Promise.promisify(wait) sleep(1):andThen(print) local isPlayerInGroup = Promise.promisify(function(player, groupId) return player:IsInGroup(groupId) end)   ","version":null,"tagName":"h3"},{"title":"delay​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#delay","content":"&lt;/&gt; Promise.delay(seconds: number) → Promise&lt;number&gt; Returns a Promise that resolves after seconds seconds have passed. The Promise resolves with the actual amount of time that was waited. This function is not a wrapper around wait. Promise.delay uses a custom scheduler which provides more accurate timing. As an optimization, cancelling this Promise instantly removes the task from the scheduler. WARNING Passing NaN, infinity, or a number less than 1/60 is equivalent to passing 1/60. Promise.delay(5):andThenCall(print, &quot;This prints after 5 seconds&quot;)   ","version":null,"tagName":"h3"},{"title":"retry​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#retry","content":"since 3.0.0 &lt;/&gt; Promise.retry( callback: (...: P) → Promise&lt;T&gt;, times: number, ...?: P ) → Promise&lt;T&gt; Repeatedly calls a Promise-returning function up to times number of times, until the returned Promise resolves. If the amount of retries is exceeded, the function will return the latest rejected Promise. local function canFail(a, b, c) return Promise.new(function(resolve, reject) -- do something that can fail local failed, thing = doSomethingThatCanFail(a, b, c) if failed then reject(&quot;it failed&quot;) else resolve(thing) end end) end local MAX_RETRIES = 10 local value = Promise.retry(canFail, MAX_RETRIES, &quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;) -- args to send to canFail   ","version":null,"tagName":"h3"},{"title":"retryWithDelay​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#retryWithDelay","content":"since v3.2.0 &lt;/&gt; Promise.retryWithDelay( callback: (...: P) → Promise&lt;T&gt;, times: number, seconds: number, ...?: P ) → Promise&lt;T&gt; Repeatedly calls a Promise-returning function up to times number of times, waiting seconds seconds between each retry, until the returned Promise resolves. If the amount of retries is exceeded, the function will return the latest rejected Promise.  ","version":null,"tagName":"h3"},{"title":"fromEvent​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#fromEvent","content":"since 3.0.0 &lt;/&gt; Promise.fromEvent( event: Event,-- Any object with a Connect method. This includes all Roblox events. predicate?: (...: P) → boolean-- A function which determines if the Promise should resolve with the given value, or wait for the next event to check again. ) → Promise&lt;P&gt; Converts an event into a Promise which resolves the next time the event fires. The optional predicate callback, if passed, will receive the event arguments and should return true or false, based on if this fired event should resolve the Promise or not. If true, the Promise resolves. If false, nothing happens and the predicate will be rerun the next time the event fires. The Promise will resolve with the event arguments. TIP This function will work given any object with a Connect method. This includes all Roblox events. -- Creates a Promise which only resolves when `somePart` is touched -- by a part named `&quot;Something specific&quot;`. return Promise.fromEvent(somePart.Touched, function(part) return part.Name == &quot;Something specific&quot; end)   ","version":null,"tagName":"h3"},{"title":"onUnhandledRejection​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#onUnhandledRejection","content":"since v3.2.0 &lt;/&gt; Promise.onUnhandledRejection( callback: ( promise: Promise, ...: any )-- A callback that runs when an unhandled rejection happens. ) → () → ()-- Function that unregisters the callback when called Registers a callback that runs when an unhandled rejection happens. An unhandled rejection happens when a Promise is rejected, and the rejection is not observed with :catch. The callback is called with the actual promise that rejected, followed by the rejection values.  ","version":null,"tagName":"h3"},{"title":"timeout​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#timeout","content":"&lt;/&gt; Promise:timeout( seconds: number, rejectionValue?: any-- The value to reject with if the timeout is reached ) → Promise Returns a new Promise that resolves if the chained Promise resolves within seconds seconds, or rejects if execution time exceeds seconds. The chained Promise will be cancelled if the timeout is reached. Rejects with rejectionValue if it is non-nil. If a rejectionValue is not given, it will reject with a Promise.Error(Promise.Error.Kind.TimedOut). This can be checked with [[Error.isKind]]. getSomething():timeout(5):andThen(function(something) -- got something and it only took at max 5 seconds end):catch(function(e) -- Either getting something failed or the time was exceeded. if Promise.Error.isKind(e, Promise.Error.Kind.TimedOut) then warn(&quot;Operation timed out!&quot;) else warn(&quot;Operation encountered an error!&quot;) end end) Sugar for: Promise.race({ Promise.delay(seconds):andThen(function() return Promise.reject( rejectionValue == nil and Promise.Error.new({ kind = Promise.Error.Kind.TimedOut }) or rejectionValue ) end), promise })   ","version":null,"tagName":"h3"},{"title":"getStatus​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#getStatus","content":"&lt;/&gt; Promise:getStatus() → Status Returns the current Promise status.  ","version":null,"tagName":"h3"},{"title":"andThen​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#andThen","content":"&lt;/&gt; Promise:andThen( successHandler: (...: any) → ...any, failureHandler?: (...: any) → ...any ) → Promise&lt;...any&gt; Chains onto an existing Promise and returns a new Promise. WARNING Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call tostring on it first. You can return a Promise from the success or failure handler and it will be chained onto. Calling andThen on a cancelled Promise returns a cancelled Promise. TIP If the Promise returned by andThen is cancelled, successHandler and failureHandler will not run. To run code no matter what, use Promise:finally.  ","version":null,"tagName":"h3"},{"title":"catch​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#catch","content":"&lt;/&gt; Promise:catch(failureHandler: (...: any) → ...any) → Promise&lt;...any&gt; Shorthand for Promise:andThen(nil, failureHandler). Returns a Promise that resolves if the failureHandler worked without encountering an additional error. WARNING Within the failure handler, you should never assume that the rejection value is a string. Some rejections within the Promise library are represented by [[Error]] objects. If you want to treat it as a string for debugging, you should call tostring on it first. Calling catch on a cancelled Promise returns a cancelled Promise. TIP If the Promise returned by catch is cancelled, failureHandler will not run. To run code no matter what, use Promise:finally.  ","version":null,"tagName":"h3"},{"title":"tap​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#tap","content":"&lt;/&gt; Promise:tap(tapHandler: (...: any) → ...any) → Promise&lt;...any&gt; Similar to Promise.andThen, except the return value is the same as the value passed to the handler. In other words, you can insert a :tap into a Promise chain without affecting the value that downstream Promises receive. getTheValue() :tap(print) :andThen(function(theValue) print(&quot;Got&quot;, theValue, &quot;even though print returns nil!&quot;) end) If you return a Promise from the tap handler callback, its value will be discarded but tap will still wait until it resolves before passing the original value through.  ","version":null,"tagName":"h3"},{"title":"andThenCall​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#andThenCall","content":"&lt;/&gt; Promise:andThenCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Attaches an andThen handler to this Promise that calls the given callback with the predefined arguments. The resolved value is discarded. promise:andThenCall(someFunction, &quot;some&quot;, &quot;arguments&quot;) This is sugar for promise:andThen(function() return someFunction(&quot;some&quot;, &quot;arguments&quot;) end)   ","version":null,"tagName":"h3"},{"title":"andThenReturn​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#andThenReturn","content":"&lt;/&gt; Promise:andThenReturn( ...: any-- Values to return from the function ) → Promise Attaches an andThen handler to this Promise that discards the resolved value and returns the given value from it. promise:andThenReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:andThen(function() return &quot;some&quot;, &quot;values&quot; end) CAUTION Promises are eager, so if you pass a Promise to andThenReturn, it will begin executing before andThenReturn is reached in the chain. Likewise, if you pass a Promise created from [[Promise.reject]] into andThenReturn, it's possible that this will trigger the unhandled rejection warning. If you need to return a Promise, it's usually best practice to use [[Promise.andThen]].  ","version":null,"tagName":"h3"},{"title":"cancel​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#cancel","content":"&lt;/&gt; Promise:cancel() → () Cancels this promise, preventing the promise from resolving or rejecting. Does not do anything if the promise is already settled. Cancellations will propagate upwards and downwards through chained promises. Promises will only be cancelled if all of their consumers are also cancelled. This is to say that if you call andThen twice on the same promise, and you cancel only one of the child promises, it will not cancel the parent promise until the other child promise is also cancelled. promise:cancel()   ","version":null,"tagName":"h3"},{"title":"finally​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#finally","content":"&lt;/&gt; Promise:finally(finallyHandler: (status: Status) → ...any) → Promise&lt;...any&gt; Set a handler that will be called regardless of the promise's fate. The handler is called when the promise is resolved, rejected, or cancelled. Returns a new Promise that: resolves with the same values that this Promise resolves with. rejects with the same values that this Promise rejects with. is cancelled if this Promise is cancelled. If the value you return from the handler is a Promise: We wait for the Promise to resolve, but we ultimately discard the resolved value. If the returned Promise rejects, the Promise returned from finally will reject with the rejected value from the returned promise. If the finally Promise is cancelled, and you returned a Promise from the handler, we cancel that Promise too. Otherwise, the return value from the finally handler is entirely discarded. Cancellation As of Promise v4, Promise:finally does not count as a consumer of the parent Promise for cancellation purposes. This means that if all of a Promise's consumers are cancelled and the only remaining callbacks are finally handlers, the Promise is cancelled and the finally callbacks run then and there. Cancellation still propagates through the finally Promise though: if you cancel the finally Promise, it can cancel its parent Promise if it had no other consumers. Likewise, if the parent Promise is cancelled, the finally Promise will also be cancelled. local thing = createSomething() doSomethingWith(thing) :andThen(function() print(&quot;It worked!&quot;) -- do something.. end) :catch(function() warn(&quot;Oh no it failed!&quot;) end) :finally(function() -- either way, destroy thing thing:Destroy() end)   ","version":null,"tagName":"h3"},{"title":"finallyCall​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#finallyCall","content":"&lt;/&gt; Promise:finallyCall( callback: (...: any) → any, ...?: any-- Additional arguments which will be passed to callback ) → Promise Same as andThenCall, except for finally. Attaches a finally handler to this Promise that calls the given callback with the predefined arguments.  ","version":null,"tagName":"h3"},{"title":"finallyReturn​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#finallyReturn","content":"&lt;/&gt; Promise:finallyReturn( ...: any-- Values to return from the function ) → Promise Attaches a finally handler to this Promise that discards the resolved value and returns the given value from it. promise:finallyReturn(&quot;some&quot;, &quot;values&quot;) This is sugar for promise:finally(function() return &quot;some&quot;, &quot;values&quot; end)   ","version":null,"tagName":"h3"},{"title":"awaitStatus​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#awaitStatus","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:awaitStatus() → ( Status,-- The Status representing the fate of the Promise ...any-- The values the Promise resolved or rejected with. ) Yields the current thread until the given Promise completes. Returns the Promise's status, followed by the values that the promise resolved or rejected with.  ","version":null,"tagName":"h3"},{"title":"await​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#await","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:await() → ( boolean,-- true if the Promise successfully resolved ...any-- The values the Promise resolved or rejected with. ) Yields the current thread until the given Promise completes. Returns true if the Promise resolved, followed by the values that the promise resolved or rejected with. CAUTION If the Promise gets cancelled, this function will return false, which is indistinguishable from a rejection. If you need to differentiate, you should use [[Promise.awaitStatus]] instead. local worked, value = getTheValue():await() if worked then print(&quot;got&quot;, value) else warn(&quot;it failed&quot;) end   ","version":null,"tagName":"h3"},{"title":"expect​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#expect","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Promise:expect() → ...any-- The values the Promise resolved with. Yields the current thread until the given Promise completes. Returns the values that the promise resolved with. local worked = pcall(function() print(&quot;got&quot;, getTheValue():expect()) end) if not worked then warn(&quot;it failed&quot;) end This is essentially sugar for: select(2, assert(promise:await())) Errors if the Promise rejects or gets cancelled. ","version":null,"tagName":"h3"},{"title":"Errors","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise##","content":"Type\tDescriptionany\tErrors with the rejection value if this Promise rejects or gets cancelled.  ","version":null,"tagName":"h3"},{"title":"now​","type":1,"pageTitle":"Promise","url":"/RoQuest/api/Promise#now","content":"&lt;/&gt; Promise:now( rejectionValue?: any-- The value to reject with if the Promise isn't resolved ) → Promise Chains a Promise from this one that is resolved if this Promise is already resolved, and rejected if it is not resolved at the time of calling :now(). This can be used to ensure your andThen handler occurs on the same frame as the root Promise execution. doSomething() :now() :andThen(function(value) print(&quot;Got&quot;, value, &quot;synchronously.&quot;) end) If this Promise is still running, Rejected, or Cancelled, the Promise returned from :now() will reject with the rejectionValue if passed, otherwise with a Promise.Error(Promise.Error.Kind.NotResolvedInTime). This can be checked with [[Error.isKind]]. ","version":null,"tagName":"h3"},{"title":"Signal","type":0,"sectionRef":"#","url":"/RoQuest/api/Signal","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Signal","url":"/RoQuest/api/Signal#types","content":" ","version":null,"tagName":"h2"},{"title":"SignalConnection​","type":1,"pageTitle":"Signal","url":"/RoQuest/api/Signal#SignalConnection","content":"&lt;/&gt; interface SignalConnection { Connected: boolean Disconnect: (SignalConnection) → () } Represents a connection to a signal. local connection = signal:Connect(function() end) print(connection.Connected) --&gt; true connection:Disconnect() print(connection.Connected) --&gt; false   ","version":null,"tagName":"h3"},{"title":"ConnectionFn​","type":1,"pageTitle":"Signal","url":"/RoQuest/api/Signal#ConnectionFn","content":"&lt;/&gt; type ConnectionFn = (...any) → () A function connected to a signal. ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Signal","url":"/RoQuest/api/Signal#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Signal","url":"/RoQuest/api/Signal#new","content":"&lt;/&gt; Signal.new() → Signal Constructs a new Signal  ","version":null,"tagName":"h3"},{"title":"Wrap​","type":1,"pageTitle":"Signal","url":"/RoQuest/api/Signal#Wrap","content":"&lt;/&gt; Signal.Wrap( rbxScriptSignal: RBXScriptSignal -- Existing RBXScriptSignal to wrap ) → Signal Constructs a new Signal that wraps around an RBXScriptSignal. For example: local signal = Signal.Wrap(workspace.ChildAdded) signal:Connect(function(part) print(part.Name .. &quot; added&quot;) end) Instance.new(&quot;Part&quot;).Parent = workspace   ","version":null,"tagName":"h3"},{"title":"Is​","type":1,"pageTitle":"Signal","url":"/RoQuest/api/Signal#Is","content":"&lt;/&gt; Signal.Is( obj: any-- Object to check ) → boolean-- true if the object is a Signal. Checks if the given object is a Signal.  ","version":null,"tagName":"h3"},{"title":"Connect​","type":1,"pageTitle":"Signal","url":"/RoQuest/api/Signal#Connect","content":"&lt;/&gt; Signal:Connect(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called anytime the signal is fired. signal:Connect(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25)   ","version":null,"tagName":"h3"},{"title":"Once​","type":1,"pageTitle":"Signal","url":"/RoQuest/api/Signal#Once","content":"&lt;/&gt; Signal:Once(fn: ConnectionFn) → SignalConnection Connects a function to the signal, which will be called the next time the signal fires. Once the connection is triggered, it will disconnect itself. signal:Once(function(msg, num) print(msg, num) end) signal:Fire(&quot;Hello&quot;, 25) signal:Fire(&quot;This message will not go through&quot;, 10)   ","version":null,"tagName":"h3"},{"title":"DisconnectAll​","type":1,"pageTitle":"Signal","url":"/RoQuest/api/Signal#DisconnectAll","content":"&lt;/&gt; Signal:DisconnectAll() → () Disconnects all connections from the signal. signal:DisconnectAll()   ","version":null,"tagName":"h3"},{"title":"Fire​","type":1,"pageTitle":"Signal","url":"/RoQuest/api/Signal#Fire","content":"&lt;/&gt; Signal:Fire(...: any) → () Fire the signal, which will call all of the connected functions with the given arguments. signal:Fire(&quot;Hello&quot;) -- Any number of arguments can be fired: signal:Fire(&quot;Hello&quot;, 32, {Test = &quot;Test&quot;}, true)   ","version":null,"tagName":"h3"},{"title":"FireDeferred​","type":1,"pageTitle":"Signal","url":"/RoQuest/api/Signal#FireDeferred","content":"&lt;/&gt; Signal:FireDeferred(...: any) → () Same as Fire, but uses task.defer internally &amp; doesn't take advantage of thread reuse. signal:FireDeferred(&quot;Hello&quot;)   ","version":null,"tagName":"h3"},{"title":"Wait​","type":1,"pageTitle":"Signal","url":"/RoQuest/api/Signal#Wait","content":"This is a yielding function. When called, it will pause the Lua thread that called the function until a result is ready to be returned, without interrupting other scripts. Yields &lt;/&gt; Signal:Wait() → ...any Yields the current thread until the signal is fired, and returns the arguments fired from the signal. Yielding the current thread is not always desirable. If the desire is to only capture the next event fired, using Once might be a better solution. task.spawn(function() local msg, num = signal:Wait() print(msg, num) --&gt; &quot;Hello&quot;, 32 end) signal:Fire(&quot;Hello&quot;, 32)   ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"Signal","url":"/RoQuest/api/Signal#Destroy","content":"&lt;/&gt; Signal:Destroy() → () Cleans up the signal. Technically, this is only necessary if the signal is created usingSignal.Wrap. Connections should be properly GC'd once the signal is no longer referenced anywhere. However, it is still good practice to include ways to strictly clean up resources. Calling Destroy on a signal will also disconnect all connections immediately. signal:Destroy()   ","version":null,"tagName":"h3"},{"title":"ConnectOnce​","type":1,"pageTitle":"Signal","url":"/RoQuest/api/Signal#ConnectOnce","content":"deprecated in v1.3.0 &lt;/&gt; This was deprecated in v1.3.0 Use `Signal:Once` instead. Signal:ConnectOnce(fn: ConnectionFn) → SignalConnection  ","version":null,"tagName":"h3"},{"title":"🤝 Accept Type","type":0,"sectionRef":"#","url":"/RoQuest/docs/AutomaticVsManual/acceptType","content":"","keywords":"","version":"Next"},{"title":"🔄 Change QuestAcceptType​","type":1,"pageTitle":"🤝 Accept Type","url":"/RoQuest/docs/AutomaticVsManual/acceptType#-change-questaccepttype","content":" When declaring a quest we can change the accept type by modifying the following property:  Quest { QuestAcceptType = RoQuest.QuestAcceptType.Automatic; }   ","version":"Next","tagName":"h2"},{"title":"🤖 Automatic​","type":1,"pageTitle":"🤝 Accept Type","url":"/RoQuest/docs/AutomaticVsManual/acceptType#-automatic","content":" This is the default behavior of our quests. With this behavior the quests will automatically be accepted by the player as soon as they become available! That's why our example quest gets given to the player as soon as he joins the game without any extra steps!  ","version":"Next","tagName":"h2"},{"title":"✋ Manual​","type":1,"pageTitle":"🤝 Accept Type","url":"/RoQuest/docs/AutomaticVsManual/acceptType#-manual","content":" Manual on the other hand requires the developer to give the quest to the player. The developer can do this by calling the function :GiveQuest  --Example RoQuest:GiveQuest(player, questId)  ","version":"Next","tagName":"h2"},{"title":"📦 Deliver Type","type":0,"sectionRef":"#","url":"/RoQuest/docs/AutomaticVsManual/DeliverType","content":"","keywords":"","version":"Next"},{"title":"🔄 Change QuestDeliverType​","type":1,"pageTitle":"📦 Deliver Type","url":"/RoQuest/docs/AutomaticVsManual/DeliverType#-change-questdelivertype","content":" When declaring a quest we can change the deliver type by modifying the following property:  Quest { QuestDeliverType = RoQuest.QuestDeliverType.Automatic; }   ","version":"Next","tagName":"h2"},{"title":"🤖 Automatic​","type":1,"pageTitle":"📦 Deliver Type","url":"/RoQuest/docs/AutomaticVsManual/DeliverType#-automatic","content":" This is the default behavior of our quests. With this behavior the quests will automatically be delivered as soon as they get completed. That's why our example quest gets delivered as soon as the player completes it!  ","version":"Next","tagName":"h2"},{"title":"✋ Manual​","type":1,"pageTitle":"📦 Deliver Type","url":"/RoQuest/docs/AutomaticVsManual/DeliverType#-manual","content":" Manual on the other hand requires the developer to deliver the quest for the player. The developer can do this by calling the function :DeliverQuest  info RoQuest only allows you to deliver a quest if it is completed. If the quest is still not complete make sure to call :CompleteQuest beforehand  --Example RoQuest:DeliverQuest(player, questId)  ","version":"Next","tagName":"h2"},{"title":"💾 How to save to DataStore","type":0,"sectionRef":"#","url":"/RoQuest/docs/DataStore","content":"","keywords":"","version":"Next"},{"title":"🔍 Native DataStore​","type":1,"pageTitle":"💾 How to save to DataStore","url":"/RoQuest/docs/DataStore#-native-datastore","content":" -- main.lua local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local DataStoreService = game:GetService(&quot;DataStoreService&quot;) local Players = game:GetService(&quot;Players&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server local questsStore = DataStoreService:GetDataStore(&quot;PlayerQuests&quot;) RoQuest:Init(RoQuest:LoadDirectory(ReplicatedStorage.Quests)) local function playerAdded(player: Player) local success, playerData = pcall(function() return questsStore:GetAsync(&quot;player_&quot;..player.UserId) end) if playerData then -- Set the data on RoQuest RoQuest:SetPlayerData(player, playerData) end end local function playerRemoved(player: Player) local success, errorMessage = pcall(function() questsStore:SetAsync(&quot;player_&quot;..player.UserId, RoQuest:GetPlayerData(player)) end) if not success then print(errorMessage) end end RoQuest.OnStart():andThen(function() Players.PlayerAdded:Connect(playerAdded) for _, player: Player in Players:GetPlayers() do playerAdded(player) end Players.PlayerRemoving:Connect(playerRemoved) end)   ","version":"Next","tagName":"h2"},{"title":"🔍 ProfileService​","type":1,"pageTitle":"💾 How to save to DataStore","url":"/RoQuest/docs/DataStore#-profileservice","content":"  local ProfileStore = ProfileService.GetProfileStore(&quot;RandomKey&quot;, {}) local profile = ProfileStore:LoadProfileAsync(&quot;USER_&quot;..userId) if not profile.Data then profile.Data = {} end if not playerData.Data.PlayerQuestData then -- New player, create new quest data playerData.Data.PlayerQuestData = PlayerQuestData {} end -- Since RoQuest stores the player data as a pointer we don't need to update anymore. Once the profile gets released it will automatically safe the player data with it RoQuest:SetPlayerData(player, playerData.Data.PlayerQuestData)  ","version":"Next","tagName":"h2"},{"title":"💡 How It Works","type":0,"sectionRef":"#","url":"/RoQuest/docs/GettingStarted/HowItWorks","content":"","keywords":"","version":"Next"},{"title":"🗺️ Quest​","type":1,"pageTitle":"💡 How It Works","url":"/RoQuest/docs/GettingStarted/HowItWorks#️-quest","content":" A quest is a piece of data that contains all the information for a quest. This includes information such as the name, description, quest chains and most importantly the objectives that are required to complete for this quest to be complete.  It's also important to understand that a quest has multiple states from: NotStarted, InProgress, Completed and Delivered.    We will go further in detail about what we are capable of doing with a Quest Object as we progress on the Docs  ","version":"Next","tagName":"h2"},{"title":"🆚 Completed vs Delivered​","type":1,"pageTitle":"💡 How It Works","url":"/RoQuest/docs/GettingStarted/HowItWorks#-completed-vs-delivered","content":" Some people might get confused when seeing this lifecycle wondering what it is the difference between completed and delivered.  Imagine you're playing an MMO RPG and have a quest giver. Once you complete this quest you'll need to go back to this NPC and tell him that your job is done. Until you inform the NPC about the quest status the quest will remain as Completed and then finally will be changed to Delivered.  &quot;But what if I don't want my players to deliver the quest in my game?&quot; Simple! There's a setting that you can modify while creating a new quest that makes quests move automatically from Completed to Delivered. (more information on that on the Automatic vs Manual Section)  ","version":"Next","tagName":"h3"},{"title":"🎯 Objective​","type":1,"pageTitle":"💡 How It Works","url":"/RoQuest/docs/GettingStarted/HowItWorks#-objective","content":" Objectives are really what keeps the quests running. On the high-level an objective is a task a player needs to complete X amounts of time. Each quest can have multiple objectives and all of these will need to be completed in order to complete the quest.  Imagine it as an integer that you need to increase until it reaches a target value.  E.g 0/2 Apples Collected 1/2 Apples Colleted 2/2 Apples Collected - Fires as completed   ","version":"Next","tagName":"h2"},{"title":"❤️ LifeCycle​","type":1,"pageTitle":"💡 How It Works","url":"/RoQuest/docs/GettingStarted/HowItWorks#️-lifecycle","content":" An example how the quest system functions when a player grabs an apple that is required for his quest:   ","version":"Next","tagName":"h2"},{"title":"📥 Installing","type":0,"sectionRef":"#","url":"/RoQuest/docs/GettingStarted/Installing","content":"📥 Installing RoQuest can be installed in different ways, depending on your project's needs. Choose the method that suits you best: 🐶 Wally🔨Studio🐙GitHub Watch wally's page roquest = &quot;prooheckcp/roquest@&gt;0.0.0, &lt;10.0.0&quot; If you installed it via the Model or GitHub I would highly recommend if you kept it under ReplicatedStorage as both the client and server should have access to it","keywords":"","version":"Next"},{"title":"RoQuestClient","type":0,"sectionRef":"#","url":"/RoQuest/api/RoQuestClient","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#properties","content":" ","version":null,"tagName":"h2"},{"title":"OnPlayerDataChanged​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#OnPlayerDataChanged","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.OnPlayerDataChanged: Signal Called whenever the player data gets changed. This should only happen when the server decides to completely overwrite the player data. Should be used to reset data on the UI and/or other client-sided displays local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnPlayerDataChanged:Connect(function(playerQuestData: PlayerQuestData) self:SetAllScreens(playerQuestData) end) -- Hard reset our screens   ","version":null,"tagName":"h3"},{"title":"OnQuestObjectiveChanged​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#OnQuestObjectiveChanged","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.OnQuestObjectiveChanged: Signal Called when one of the quest's objective gets changed. Useful to update UI elements local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnQuestObjectiveChanged:Connect(function(questId: string, objectiveId: string, newValue: number) self:UpdateObjective(RoQuest:GetQuest(questId), objectiveId, newValue) end)   ","version":null,"tagName":"h3"},{"title":"OnQuestStarted​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#OnQuestStarted","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.OnQuestStarted: Signal Called whenever the player starts a new quest! local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnQuestStarted:Connect(function(questId: string) print(&quot;Player has started the quest: &quot;, RoQuest:GetQuest(questId).Name) end)   ","version":null,"tagName":"h3"},{"title":"OnQuestCompleted​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#OnQuestCompleted","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.OnQuestCompleted: Signal Called whenever the player completes a quest! local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnQuestCompleted:Connect(function(questId: string) print(&quot;Player has completed the quest: &quot;, RoQuest:GetQuest(questId).Name) end)   ","version":null,"tagName":"h3"},{"title":"OnQuestDelivered​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#OnQuestDelivered","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.OnQuestDelivered: Signal Called whenever the player delivers a quest! local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnQuestDelivered:Connect(function(questId: string) print(&quot;Player has delivered the quest: &quot;, RoQuest:GetQuest(questId).Name) end)   ","version":null,"tagName":"h3"},{"title":"OnQuestCancelled​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#OnQuestCancelled","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.OnQuestCancelled: Signal Called whenever a quest gets cancelled. This might happen when a player asks to cancel a quest or the developer disables a quest at run-time (per example when an event finishes) local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnQuestCancelled:Connect(function(questId: string) print(&quot;The following quest just got removed: &quot;, RoQuest:GetQuest(questId).Name) end)   ","version":null,"tagName":"h3"},{"title":"OnQuestAvailable​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#OnQuestAvailable","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.OnQuestAvailable: Signal This gets called when a quest becomes available. This usually means that the player can now accept this quest at a given quest giver local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnQuestAvailable:Connect(function(questId: string) print(&quot;The following quest just became available: &quot;, RoQuest:GetQuest(questId).Name) end)   ","version":null,"tagName":"h3"},{"title":"OnQuestUnavailable​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#OnQuestUnavailable","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.OnQuestUnavailable: Signal This gets called when a quest becomes unavailable. Usually only happens when a quest gets disabled at run-time or when the quest's end time has passed local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnQuestUnavailable:Connect(function(questId: string) print(&quot;The player's quest has just been cancelled: &quot;, RoQuest:GetStaticQuest(questId).Name) end)   ","version":null,"tagName":"h3"},{"title":"OnUnAvailableQuestChanged​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#OnUnAvailableQuestChanged","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.OnUnAvailableQuestChanged: Signal This gets called whenever the quests that are unavailable changes. This means that either a quest just became available OR that a quest became unavailable (such as a quest with an end time) local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnUnAvailableQuestChanged:Connect(function() print(self:GetUnAvailableQuests()) end)   ","version":null,"tagName":"h3"},{"title":"OnAvailableQuestChanged​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#OnAvailableQuestChanged","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.OnAvailableQuestChanged: Signal This gets called whenever the quests that are available changes. Called when one of the available quests becomes unavailable or when a quest gets started by the player local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnAvailableQuestChanged:Connect(function() print(self:GetAvailableQuests()) end)   ","version":null,"tagName":"h3"},{"title":"OnCompletedQuestChanged​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#OnCompletedQuestChanged","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.OnCompletedQuestChanged: Signal This gets called whenever the quests that are completed changes. This gets called when either a quest got delivered, a quest just got completed or somehow the quest got cancelled while completed local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnCompletedQuestChanged:Connect(function() print(self:GetCompletedQuests()) end)   ","version":null,"tagName":"h3"},{"title":"OnDeliveredQuestChanged​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#OnDeliveredQuestChanged","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.OnDeliveredQuestChanged: Signal This gets called whenever the quests that are delivered changes. This gets called when either a quest got delivered or a delivered quest gets restarted local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnDeliveredQuestChanged:Connect(function() print(self:GetDeliveredQuests()) end)   ","version":null,"tagName":"h3"},{"title":"OnInProgressQuestChanged​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#OnInProgressQuestChanged","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.OnInProgressQuestChanged: Signal This gets called whenever the quests that are in progress change. This gets called when either a quest got completed or started by the player local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnInProgressQuestChanged:Connect(function() print(self:GetInProgressQuests()) end)   ","version":null,"tagName":"h3"},{"title":"Quest​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#Quest","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.Quest: Quest This is a reference to our Quest class  ","version":null,"tagName":"h3"},{"title":"QuestLifeCycle​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#QuestLifeCycle","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.QuestLifeCycle: QuestLifeCycle This is a reference to our QuestLifeCycle class  ","version":null,"tagName":"h3"},{"title":"ObjectiveInfo​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#ObjectiveInfo","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.ObjectiveInfo: ObjectiveInfo This is a reference to our ObjectiveInfo class  ","version":null,"tagName":"h3"},{"title":"QuestAcceptType​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#QuestAcceptType","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.QuestAcceptType: QuestAcceptType This is a reference to our QuestAcceptType enum  ","version":null,"tagName":"h3"},{"title":"QuestDeliverType​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#QuestDeliverType","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.QuestDeliverType: QuestDeliverType This is a reference to our QuestDeliverType enum  ","version":null,"tagName":"h3"},{"title":"QuestRepeatableType​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#QuestRepeatableType","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.QuestRepeatableType: QuestRepeatableType This is a reference to our QuestRepeatableType enum  ","version":null,"tagName":"h3"},{"title":"QuestStatus​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#QuestStatus","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.QuestStatus: QuestStatus This is a reference to our QuestStatus enum ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#functions","content":" ","version":null,"tagName":"h2"},{"title":"OnStart​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#OnStart","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient.OnStart() → Promise This is one of the most important methods of this Module. It is used to ensure that your code is only called after the RoQuestClient has been initiated. It is safe to get player data and quest data after this method has been called local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnStart():andThen(function() print(&quot;RoQuestClient has been initiated!&quot;) RoQuest.OnQuestStarted:Connect(function(questId: string) print(&quot;Player has started the quest: &quot;, RoQuest:GetQuest(questId).Name) end) RoQuest.OnQuestCompleted:Connect(function(questId: string) print(&quot;Player has completed the quest: &quot;, RoQuest:GetQuest(questId).Name) end) end)   ","version":null,"tagName":"h3"},{"title":"Init​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#Init","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient:Init(lifeCycles: {QuestLifeCycle}?) → ()  INFO This function can and should only be called once. It is used to initialize the RoQuestClient Feed the lifecycles of our quests into the Module and initialize the RoQuestClient local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest:Init()   ","version":null,"tagName":"h3"},{"title":"LoadDirectory​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#LoadDirectory","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient:LoadDirectory(directory: {Instance }) → {Quest | QuestLifeCycle}-- Returns an array with either just Quests or QuestLifeCycles Loads all the quests and lifecycles right under the given director and returns them in an array local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest:Init(RoQuest:LoadDirectory(ReplicatedStorage.Quests))   ","version":null,"tagName":"h3"},{"title":"LoadDirectoryDeep​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#LoadDirectoryDeep","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient:LoadDirectoryDeep(directory: {Instance }) → {Quest | QuestLifeCycle}-- Returns an array with either just Quests or QuestLifeCycles Loads all the quests and lifecycles from the descendants of the directory and returns them in an array. The difference from :LoadDirectoryDeep and :LoadDirectory is that this one takes all descendants into account instead of just the children local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest:Init(RoQuest:LoadDirectoryDeep(ReplicatedStorage.Quests))   ","version":null,"tagName":"h3"},{"title":"GetStaticQuest​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#GetStaticQuest","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient:GetStaticQuest(questId: string) → Quest? Gets the static data of a cached quest local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnStart():andThen(function() local quest: Quest? = RoQuest:GetStaticQuest(&quot;QuestId&quot;) if quest then print(quest.Name) end end)   ","version":null,"tagName":"h3"},{"title":"GetStaticQuests​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#GetStaticQuests","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient:GetStaticQuests() → {[string]: Quest} Gets the static data of all of the cached quests local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnStart():andThen(function() local quests: {[string]: Quest} = RoQuest:GetStaticQuests() for questId: string, quest: Quest in pairs(quests) do -- Prints the name of all the quests print(quest.Name) end end)   ","version":null,"tagName":"h3"},{"title":"GetQuest​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#GetQuest","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient:GetQuest(questId: string) → Quest? Gets a player quest object. It will return nil if the player has never started the quest! local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnStart():andThen(function() local quest: Quest? = RoQuest:GetQuest(&quot;QuestId&quot;) if quest then print(quest.Name) else print(&quot;Player never started this quest!&quot;) end end)   ","version":null,"tagName":"h3"},{"title":"GetQuests​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#GetQuests","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient:GetQuests() → {[string]: Quest}-- &lt;questId: string, quest: Quest&gt; Gets all the quests from the player. This includes quests InProgress, Completed and Delivered local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnStart():andThen(function() local quests: {[string]: Quest} = RoQuest:GetQuests() for questId: string, quest: Quest in pairs(quests) do print(quest.Name) end end)   ","version":null,"tagName":"h3"},{"title":"GetCompletedQuests​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#GetCompletedQuests","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient:GetCompletedQuests() → {[string]: Quest}-- &lt;questId: string, quest: Quest&gt; Gets all the quests that have already been completed by the player local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnStart():andThen(function() local quests: {[string]: Quest} = RoQuest:GetCompletedQuests() for questId: string, quest: Quest in pairs(quests) do print(quest.Name, &quot; is completed!&quot;) end end)   ","version":null,"tagName":"h3"},{"title":"GetDeliveredQuests​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#GetDeliveredQuests","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient:GetDeliveredQuests() → {[string]: Quest}-- &lt;questId: string, quest: Quest&gt; Gets all the quests that have already been delivered by the player local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnStart():andThen(function() local quests: {[string]: Quest} = RoQuest:GetDeliveredQuests() for questId: string, quest: Quest in pairs(quests) do print(quest.Name, &quot; is delivered!&quot;) end end)   ","version":null,"tagName":"h3"},{"title":"GetInProgressQuests​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#GetInProgressQuests","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient:GetInProgressQuests() → {[string]: Quest}-- &lt;questId: string, quest: Quest&gt; Gets all the quests that the player currently has in progress local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnStart():andThen(function() local quests: {[string]: Quest} = RoQuest:GetInProgressQuests() for questId: string, quest: Quest in pairs(quests) do print(quest.Name, &quot; is in progress!&quot;) end end)   ","version":null,"tagName":"h3"},{"title":"GetAvailableQuests​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#GetAvailableQuests","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient:GetAvailableQuests() → {[string]: Quest}-- &lt;questId: string, quest: Quest&gt; Gets all the available quests that the player currently has local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnStart():andThen(function() local quests: {[string]: Quest} = RoQuest:GetAvailableQuests() for questId: string, quest: Quest in pairs(quests) do print(quest.Name, &quot; is available!&quot;) end end)   ","version":null,"tagName":"h3"},{"title":"GetUnAvailableQuests​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#GetUnAvailableQuests","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient:GetUnAvailableQuests() → {[string]: Quest}-- &lt;questId: string, quest: Quest&gt; Gets all the unavailable quests that the player currently has local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnStart():andThen(function() local quests: {[string]: Quest} = RoQuest:GetUnAvailableQuests() for questId: string, quest: Quest in pairs(quests) do print(quest.Name, &quot; is unavailable!&quot;) end end)   ","version":null,"tagName":"h3"},{"title":"CanGiveQuest​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#CanGiveQuest","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient:CanGiveQuest(questId: string) → boolean-- If we can or not give the quest to the player Checks if the player can accept the quest or not local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest.OnStart():andThen(function() if RoQuest:CanGiveQuest(&quot;QuestId&quot;) then print(&quot;Player can accept the quest!&quot;) else print(&quot;Player cannot accept the quest!&quot;) end end)   ","version":null,"tagName":"h3"},{"title":"GetQuestStatus​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#GetQuestStatus","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient:GetQuestStatus(questId: string) → QuestStatus Get the quest status  ","version":null,"tagName":"h3"},{"title":"GetLifeCycle​","type":1,"pageTitle":"RoQuestClient","url":"/RoQuest/api/RoQuestClient#GetLifeCycle","content":"This item only works when running on the client. Client &lt;/&gt; RoQuestClient:GetLifeCycle( questId: string, lifeCycleName: string ) → QuestLifeCycle? Gets a lifecycle object from a quest by the name ","version":null,"tagName":"h3"},{"title":"🔧 Setting Up","type":0,"sectionRef":"#","url":"/RoQuest/docs/GettingStarted/SettingUp","content":"","keywords":"","version":"Next"},{"title":"📐 Structure​","type":1,"pageTitle":"🔧 Setting Up","url":"/RoQuest/docs/GettingStarted/SettingUp#-structure","content":" Now that RoQuest is finally installed it is time to set it up! In order for it to work we need to both Init it from our Client and Server! What I would personally recommend would be having a local script and a server script specifically just for loading the quest system but feel free to organize it as you please.  And don't worry, the system still works fine if loaded with a delay in case you are using loader framework like Knit.  ","version":"Next","tagName":"h2"},{"title":"📜 Scripts Content​","type":1,"pageTitle":"🔧 Setting Up","url":"/RoQuest/docs/GettingStarted/SettingUp#-scripts-content","content":" warning The code from the Client and Server are separate. Make sure that you are using RoQuest.Sever when accessing it from the server-side and RoQuest.Client when on the client-side.  -- Server Script local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest:Init({})   -- Client Script local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest:Init()   The Init function on the server-side takes an array of quests as the first argument. We'll be creating our first quest and feeding it into the system in the next section! ","version":"Next","tagName":"h2"},{"title":"🤔 About","type":0,"sectionRef":"#","url":"/RoQuest/docs/intro","content":"","keywords":"","version":"Next"},{"title":"🔍 Why RoQuest​","type":1,"pageTitle":"🤔 About","url":"/RoQuest/docs/intro#-why-roquest","content":" One of the most common yet most challenging systems that games require are quest systems. These systems should be capable of containing, tracking and reacting to progress of the player during his playtime.  Since this is such a heavy system and that should be avoided to be hardcoded I decided to make an abstract one that would allow me to easily add quest systems to all my projects. I then decided to open-source it to contribute to the community and possibly have the help of other developers in order to improve this system even further!  ","version":"Next","tagName":"h2"},{"title":"🔥 Main Features​","type":1,"pageTitle":"🤔 About","url":"/RoQuest/docs/intro#-main-features","content":" Support for Repeatable QuestsHighly customizable behaviorSupport for LifeCycles attached to questsServer to Client replication to meet your UI needsEasy way of getting and loading player data (to connect to a DataStore) ","version":"Next","tagName":"h2"},{"title":"🤔 What is a lifecycle?","type":0,"sectionRef":"#","url":"/RoQuest/docs/LifeCycles/WhatIsLifeCycle","content":"","keywords":"","version":"Next"},{"title":"Client Vs Server​","type":1,"pageTitle":"🤔 What is a lifecycle?","url":"/RoQuest/docs/LifeCycles/WhatIsLifeCycle#client-vs-server","content":" LifeCycles can both run on the server and or client. This all depends on how the developer injects the lifeCycles into their RoQuest! I'll be showing some examples on the following section for lifeCycles. ","version":"Next","tagName":"h2"},{"title":"Trove","type":0,"sectionRef":"#","url":"/RoQuest/api/Trove","content":"","keywords":"","version":null},{"title":"Types​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#types","content":" ","version":null,"tagName":"h2"},{"title":"Trackable​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#Trackable","content":"&lt;/&gt; type Trackable = Instance | ConnectionLike | PromiseLike | thread | ((...any) → ...any) | Destroyable | DestroyableLowercase | Disconnectable | DisconnectableLowercase Represents all trackable objects by Trove.  ","version":null,"tagName":"h3"},{"title":"ConnectionLike​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#ConnectionLike","content":"&lt;/&gt; interface ConnectionLike { Connected: boolean Disconnect: (self) → () }   ","version":null,"tagName":"h3"},{"title":"SignalLike​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#SignalLike","content":"&lt;/&gt; interface SignalLike { Connect: ( self, callback: (...any) → ...any ) → ConnectionLike Once: ( self, callback: (...any) → ...any ) → ConnectionLike }   ","version":null,"tagName":"h3"},{"title":"PromiseLike​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#PromiseLike","content":"&lt;/&gt; interface PromiseLike { getStatus: (self) → string finally: ( self, callback: (...any) → ...any ) → PromiseLike cancel: (self) → () }   ","version":null,"tagName":"h3"},{"title":"Constructable​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#Constructable","content":"&lt;/&gt; type Constructable = {new: (A...) → T} | (A...) → T   ","version":null,"tagName":"h3"},{"title":"Destroyable​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#Destroyable","content":"&lt;/&gt; interface Destroyable { disconnect: (self) → () }   ","version":null,"tagName":"h3"},{"title":"DestroyableLowercase​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#DestroyableLowercase","content":"&lt;/&gt; interface DestroyableLowercase { disconnect: (self) → () }   ","version":null,"tagName":"h3"},{"title":"Disconnectable​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#Disconnectable","content":"&lt;/&gt; interface Disconnectable { disconnect: (self) → () }   ","version":null,"tagName":"h3"},{"title":"DisconnectableLowercase​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#DisconnectableLowercase","content":"&lt;/&gt; interface DisconnectableLowercase { disconnect: (self) → () }  ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#functions","content":" ","version":null,"tagName":"h2"},{"title":"new​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#new","content":"&lt;/&gt; Trove.new() → Trove Constructs a Trove object. local trove = Trove.new()   ","version":null,"tagName":"h3"},{"title":"Add​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#Add","content":"&lt;/&gt; Trove:Add( object: any,-- Object to track cleanupMethod: string?-- Optional cleanup name override ) → object: any Adds an object to the trove. Once the trove is cleaned or destroyed, the object will also be cleaned up. The following types are accepted (e.g. typeof(object)): Type Cleanup Instance object:Destroy() RBXScriptConnection object:Disconnect() function object() thread task.cancel(object) table object:Destroy() or object:Disconnect() or object:destroy() or object:disconnect() table with cleanupMethod object:&lt;cleanupMethod&gt;() Returns the object added. -- Add a part to the trove, then destroy the trove, -- which will also destroy the part: local part = Instance.new(&quot;Part&quot;) trove:Add(part) trove:Destroy() -- Add a function to the trove: trove:Add(function() print(&quot;Cleanup!&quot;) end) trove:Destroy() -- Standard cleanup from table: local tbl = {} function tbl:Destroy() print(&quot;Cleanup&quot;) end trove:Add(tbl) -- Custom cleanup from table: local tbl = {} function tbl:DoSomething() print(&quot;Do something on cleanup&quot;) end trove:Add(tbl, &quot;DoSomething&quot;)   ","version":null,"tagName":"h3"},{"title":"Clone​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#Clone","content":"&lt;/&gt; Trove:Clone() → Instance  Clones the given instance and adds it to the trove. Shorthand fortrove:Add(instance:Clone()). local clonedPart = trove:Clone(somePart)   ","version":null,"tagName":"h3"},{"title":"Construct​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#Construct","content":"&lt;/&gt; Trove:Construct( class: {new(Args...) → T} | (Args...) → T, ...: Args... ) → T Constructs a new object from either the table or function given. If a table is given, the table's new function will be called with the given arguments. If a function is given, the function will be called with the given arguments. The result from either of the two options will be added to the trove. This is shorthand for trove:Add(SomeClass.new(...)) and trove:Add(SomeFunction(...)). local Signal = require(somewhere.Signal) -- All of these are identical: local s = trove:Construct(Signal) local s = trove:Construct(Signal.new) local s = trove:Construct(function() return Signal.new() end) local s = trove:Add(Signal.new()) -- Even Roblox instances can be created: local part = trove:Construct(Instance, &quot;Part&quot;)   ","version":null,"tagName":"h3"},{"title":"Connect​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#Connect","content":"&lt;/&gt; Trove:Connect( signal: RBXScriptSignal , fn: (...: any) → () ) → RBXScriptConnection  Connects the function to the signal, adds the connection to the trove, and then returns the connection. This is shorthand for trove:Add(signal:Connect(fn)). trove:Connect(workspace.ChildAdded, function(instance) print(instance.Name .. &quot; added to workspace&quot;) end)   ","version":null,"tagName":"h3"},{"title":"BindToRenderStep​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#BindToRenderStep","content":"&lt;/&gt; Trove:BindToRenderStep( name: string, priority: number, fn: (dt: number) → () ) → () Calls RunService:BindToRenderStep and registers a function in the trove that will call RunService:UnbindFromRenderStep on cleanup. trove:BindToRenderStep(&quot;Test&quot;, Enum.RenderPriority.Last.Value, function(dt) -- Do something end)   ","version":null,"tagName":"h3"},{"title":"AddPromise​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#AddPromise","content":"&lt;/&gt; Trove:AddPromise(promise: Promise) → Promise Gives the promise to the trove, which will cancel the promise if the trove is cleaned up or if the promise is removed. The exact promise is returned, thus allowing chaining. trove:AddPromise(doSomethingThatReturnsAPromise()) :andThen(function() print(&quot;Done&quot;) end) -- Will cancel the above promise (assuming it didn't resolve immediately) trove:Clean() local p = trove:AddPromise(doSomethingThatReturnsAPromise()) -- Will also cancel the promise trove:Remove(p) Promise v4 Only This is only compatible with the roblox-lua-promise library, version 4.  ","version":null,"tagName":"h3"},{"title":"Remove​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#Remove","content":"&lt;/&gt; Trove:Remove(object: any) → () Removes the object from the Trove and cleans it up. local part = Instance.new(&quot;Part&quot;) trove:Add(part) trove:Remove(part)   ","version":null,"tagName":"h3"},{"title":"Extend​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#Extend","content":"&lt;/&gt; Trove:Extend() → Trove Creates and adds another trove to itself. This is just shorthand for trove:Construct(Trove). This is useful for contexts where the trove object is present, but the class itself isn't. NOTE This does not clone the trove. In other words, the objects in the trove are not given to the new constructed trove. This is simply to construct a new Trove and add it as an object to track. local trove = Trove.new() local subTrove = trove:Extend() trove:Clean() -- Cleans up the subTrove too   ","version":null,"tagName":"h3"},{"title":"Clean​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#Clean","content":"&lt;/&gt; Trove:Clean() → () Cleans up all objects in the trove. This is similar to calling Remove on each object within the trove. The ordering of the objects removed is not guaranteed. trove:Clean()   ","version":null,"tagName":"h3"},{"title":"AttachToInstance​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#AttachToInstance","content":"&lt;/&gt; Trove:AttachToInstance(instance: Instance ) → RBXScriptConnection  Attaches the trove to a Roblox instance. Once this instance is removed from the game (parent or ancestor's parent set to nil), the trove will automatically clean up. This inverses the ownership of the Trove object, and should only be used when necessary. In other words, the attached instance dictates when the trove is cleaned up, rather than the trove dictating the cleanup of the instance. CAUTION Will throw an error if instance is not a descendant of the game hierarchy. trove:AttachToInstance(somePart) trove:Add(function() print(&quot;Cleaned&quot;) end) -- Destroying the part will cause the trove to clean up, thus &quot;Cleaned&quot; printed: somePart:Destroy()   ","version":null,"tagName":"h3"},{"title":"Destroy​","type":1,"pageTitle":"Trove","url":"/RoQuest/api/Trove#Destroy","content":"&lt;/&gt; Trove:Destroy() → () Alias for trove:Clean(). trove:Destroy()  ","version":null,"tagName":"h3"},{"title":"♻️ Creating LifeCycle","type":0,"sectionRef":"#","url":"/RoQuest/docs/LifeCycles/CreatingLifeCycle","content":"","keywords":"","version":"Next"},{"title":"🪜 Create Stairs​","type":1,"pageTitle":"♻️ Creating LifeCycle","url":"/RoQuest/docs/LifeCycles/CreatingLifeCycle#-create-stairs","content":" Now that we have a base understanding of a lifecycle let's take a look at it in action!  For this example we'll make an object that is too high for the player to collect! However whenever the player accepts the quest stairs spawn in! These stairs will allow the player to climb up and get the object!  Remember the apple quest from the earlier sections? We'll be using that for this one too! Let's start by creating a platform and some stairs...    Make sure to keep the stairs as their own model!  ","version":"Next","tagName":"h2"},{"title":"📂 Create Folder Structure​","type":1,"pageTitle":"♻️ Creating LifeCycle","url":"/RoQuest/docs/LifeCycles/CreatingLifeCycle#-create-folder-structure","content":" For me this is one of the most important steps to take into account! We want to make sure that we have a good place to store our lifeCycles. The following example is my personal recommendation but feel free to store lifecycles as you please!    ","version":"Next","tagName":"h2"},{"title":"💖 Create LifeCycle​","type":1,"pageTitle":"♻️ Creating LifeCycle","url":"/RoQuest/docs/LifeCycles/CreatingLifeCycle#-create-lifecycle","content":" Now let's make the lifecycle! Since we only want to display the stairs for 1 player we'll create this lifecycle on the client folder! Here's an example:  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client local QuestLifeCycle = RoQuest.QuestLifeCycle { Name = &quot;AppleLifeCycle&quot; -- Important unique identifier } function QuestLifeCycle:OnInit() -- Called when the player joins self.stairs = workspace.Stairs self.stairs.Parent = ReplicatedStorage end function QuestLifeCycle:OnStart() self.stairs.Parent = workspace end function QuestLifeCycle:OnDeliver() self.stairs.Parent = ReplicatedStorage end return QuestLifeCycle   ","version":"Next","tagName":"h2"},{"title":"🔧 Setup Lifecycle​","type":1,"pageTitle":"♻️ Creating LifeCycle","url":"/RoQuest/docs/LifeCycles/CreatingLifeCycle#-setup-lifecycle","content":" Now that we created our lifecycle we need to connect it to the quest we wish  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server local appleObjective = require(ReplicatedStorage.QuestObjectives.AppleInfo) local Quest = RoQuest.Quest return Quest { Name = &quot;Collect Apples&quot;, Description = &quot;Collect 2 apples&quot;, QuestId = &quot;AppleCollection&quot;, LifeCycles = {&quot;AppleQuest&quot;}, -- The lifecycles that will manage this quest's behavior QuestObjectives = { appleObjective:NewObjective(2) }, }   ","version":"Next","tagName":"h2"},{"title":"⌛ Load LifeCycles​","type":1,"pageTitle":"♻️ Creating LifeCycle","url":"/RoQuest/docs/LifeCycles/CreatingLifeCycle#-load-lifecycles","content":" info Please remember that lifecycles need to be loaded in both the client and server  -- Server local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local DataStoreService = game:GetService(&quot;DataStoreService&quot;) local Players = game:GetService(&quot;Players&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server local questsStore = DataStoreService:GetDataStore(&quot;PlayerQuests&quot;) RoQuest:Init(RoQuest:LoadDirectory(ReplicatedStorage.Quests), RoQuest:LoadDirectory(ReplicatedStorage.LifeCycles.Server))   -- Client local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client RoQuest:Init(RoQuest:LoadDirectory(ReplicatedStorage.LifeCycles.Client))  ","version":"Next","tagName":"h2"},{"title":"🍎 Creating Object","type":0,"sectionRef":"#","url":"/RoQuest/docs/MyFirstQuest/CreatingObject","content":"","keywords":"","version":"Next"},{"title":"🍎 Creating the Apple​","type":1,"pageTitle":"🍎 Creating Object","url":"/RoQuest/docs/MyFirstQuest/CreatingObject#-creating-the-apple","content":" Let's create a few red balls. Make sure to anchor them and then add them a tag called &quot;Apple&quot;    ","version":"Next","tagName":"h2"},{"title":"💻 Code​","type":1,"pageTitle":"🍎 Creating Object","url":"/RoQuest/docs/MyFirstQuest/CreatingObject#-code","content":" Great, now that we have out apples we need to create their code. Here's an example of a code I did that allows us to collect the apples. I made this code its own server script under ServerScriptService  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local CollectionService = game:GetService(&quot;CollectionService&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server local function appleAdded(apple) local clone = apple:Clone() local proximityPrompt = Instance.new(&quot;ProximityPrompt&quot;) proximityPrompt.ActionText = &quot;Collect Apple&quot; proximityPrompt.HoldDuration = 0.25 proximityPrompt.Triggered:Connect(function(player) apple:Destroy() RoQuest:AddObjective(player, &quot;Apple&quot;, 1) -- Add to the quest task.delay(5, function() -- Respawn after 5 seconds clone.Parent = workspace end) end) proximityPrompt.Parent = apple end CollectionService:GetInstanceAddedSignal(&quot;Apple&quot;):Connect(appleAdded) for _, apple in CollectionService:GetTagged(&quot;Apple&quot;) do appleAdded(apple) end   I know this is a lot to digest but the only part you really need to look into is inside the proximityPrompt.Triggered. As you can see we called  RoQuest:AddObjective(player, &quot;Apple&quot;, 1)  What this function does is tell our quest system that hey the player just collected an apple, try to add to his quests 1 of apple! But wait, we still didn't tell our system that the quest requires you to collect apples in order to be complete! ","version":"Next","tagName":"h2"},{"title":"✍️ Declaring Quest","type":0,"sectionRef":"#","url":"/RoQuest/docs/MyFirstQuest/DeclaringQuest","content":"","keywords":"","version":"Next"},{"title":"📐 Structure​","type":1,"pageTitle":"✍️ Declaring Quest","url":"/RoQuest/docs/MyFirstQuest/DeclaringQuest#-structure","content":" My recommendation when creating quests is to create a folder called Quests. It will be in this folder that we store all our quests in their own Module Scripts.  Start by creating a folder and inside of it create a quest called Apple    ","version":"Next","tagName":"h2"},{"title":"👀 Example​","type":1,"pageTitle":"✍️ Declaring Quest","url":"/RoQuest/docs/MyFirstQuest/DeclaringQuest#-example","content":" -- Apple.lua local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server local Quest = RoQuest.Quest return Quest { Name = &quot;Collect Apples&quot;, -- The name of our quest Description = &quot;Collect 2 apples&quot;, -- The description that we will display to our user QuestId = &quot;AppleCollection&quot;, -- A unique identifier to our quest QuestAcceptType = RoQuest.QuestAcceptType.Automatic, -- If the quest automatically gets accepted or rquires manual work QuestDeliverType = RoQuest.QuestDeliverType.Automatic, -- If the quest automatically gets delivered or requires manual work QuestRepeatableType = RoQuest.QuestRepeatableType.NonRepeatable, -- If the quest can be repeated or not QuestStart = -1, -- UTC time to define when the quest should become available (specially useful for event quests) QuestEnd = -1, -- UTC time to define when the quest should no longer be available (specially useful for event quests) RequiredQuests = {}, -- A list of quests that are required to be delivered before this quest can be started LifeCycles = {}, -- The lifecycles that will manage this quest's behavior QuestObjectives = {}, }  ","version":"Next","tagName":"h2"},{"title":"🎯 Quest Objectives","type":0,"sectionRef":"#","url":"/RoQuest/docs/MyFirstQuest/QuestObjectives","content":"","keywords":"","version":"Next"},{"title":"📐 Structure​","type":1,"pageTitle":"🎯 Quest Objectives","url":"/RoQuest/docs/MyFirstQuest/QuestObjectives#-structure","content":" My recommendation, similar to quests, is to create a folder for Quest Objectives. Let's create this folder under ReplicatedStorage and add a new ModuleScript in called AppleInfo.    ","version":"Next","tagName":"h2"},{"title":"👀 Example​","type":1,"pageTitle":"🎯 Quest Objectives","url":"/RoQuest/docs/MyFirstQuest/QuestObjectives#-example","content":" -- AppleObjective.lua local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server local ObjectiveInfo = RoQuest.ObjectiveInfo return ObjectiveInfo.new { Description = &quot;%s/%s apples collected&quot;, -- This is the description, the %s's refer to the current progress and goal progress Name = &quot;Collect Apples&quot;, -- The name of our objective ObjectiveId = &quot;Apple&quot;, -- A unique identifier to this objective }   Please keep in mind that the ObjectiveId is what you'll use as a reference when setting the progress for this objective ","version":"Next","tagName":"h2"},{"title":"🎬 Wrap Up","type":0,"sectionRef":"#","url":"/RoQuest/docs/MyFirstQuest/WrapUp","content":"","keywords":"","version":"Next"},{"title":"🎯 Adding Objective to Quest​","type":1,"pageTitle":"🎬 Wrap Up","url":"/RoQuest/docs/MyFirstQuest/WrapUp#-adding-objective-to-quest","content":" Now that we have both our quest and objective done we need to add this to the quest. To do so you just need to require the quest objective. Once you did that you can call the function :NewObjective(target)  -- Apple.lua local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server local appleObjective = require(ReplicatedStorage.QuestObjectives.AppleInfo) local Quest = RoQuest.Quest return Quest { Name = &quot;Collect Apples&quot;, -- The name of our quest Description = &quot;Collect 2 apples&quot;, -- The description that we will display to our user QuestId = &quot;AppleCollection&quot;, -- A unique identifier to our quest QuestAcceptType = RoQuest.QuestAcceptType.Automatic, -- If the quest automatically gets accepted or rquires manual work QuestDeliverType = RoQuest.QuestDeliverType.Automatic, -- If the quest automatically gets delivered or requires manual work QuestRepeatableType = RoQuest.QuestRepeatableType.NonRepeatable, -- If the quest can be repeated or not QuestStart = -1, -- UTC time to define when the quest should become available (specially useful for event quests) QuestEnd = -1, -- UTC time to define when the quest should no longer be available (specially useful for event quests) RequiredQuests = {}, -- A list of quests that are required to be delivered before this quest can be started LifeCycles = {&quot;AppleQuest&quot;}, -- The lifecycles that will manage this quest's behavior QuestObjectives = { appleObjective:NewObjective(2) -- Creates an objective with a goal of 2 }, }   In the example above we created an objective with a goal of 2. Basically the player needs to collect 2 apples in order to complete this quest! A quest can contain an infinite amount of objects!  ","version":"Next","tagName":"h2"},{"title":"💾 Load quest into RoQuest​","type":1,"pageTitle":"🎬 Wrap Up","url":"/RoQuest/docs/MyFirstQuest/WrapUp#-load-quest-into-roquest","content":" In the server-side, we now need to feed the quests into RoQuest in order for the library to know that they exist. Remember the :Init function? Yes, we passed an empty table into it! You should instead of an empty table, you should send an array with all your quests into it.  To help you doing this you can take advantage of a neat function called LoadDirectory. See the following example:  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest:Init(RoQuest:LoadDirectory(ReplicatedStorage.Quests))   ","version":"Next","tagName":"h2"},{"title":"🔍 Track Progress​","type":1,"pageTitle":"🎬 Wrap Up","url":"/RoQuest/docs/MyFirstQuest/WrapUp#-track-progress","content":" Okay but now how do we know when the player completed the quest? We don't have any UI or feedback to indicate that! In the next section I'll teach you how to make a UI to track the quests and make your own quest log but for now let's just use some events to listen to changes to the quest.  info When accessing to anything from RoQuest the developer shoud use RoQuest.OnStart (returns a Promise) to ensure that the quest system has been initiated  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest:Init(RoQuest:LoadDirectory(ReplicatedStorage.Quests)) RoQuest.OnStart():andThen(function() RoQuest.OnQuestObjectiveChanged:Connect(function(player: Player, questId: string, objectiveId: string, newValue: number) print(player.Name, &quot; got &quot;, newValue, objectiveId) end) RoQuest.OnQuestCompleted:Connect(function(player: Player, questId: string) print(player.Name, &quot; just completed the quest: &quot;, questId) end) end)  ","version":"Next","tagName":"h2"},{"title":"RoQuestServer","type":0,"sectionRef":"#","url":"/RoQuest/api/RoQuestServer","content":"","keywords":"","version":null},{"title":"Properties​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#properties","content":" ","version":null,"tagName":"h2"},{"title":"OnPlayerDataChanged​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#OnPlayerDataChanged","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.OnPlayerDataChanged: Signal Called whenever the player data gets changed. This should only happen when we decide to completely overwrite the player data local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnPlayerDataChanged:Connect(function(player: Player, playerQuestData: PlayerQuestData) self:SetAllScreens(playerQuestData) end) -- Hard reset our screens   ","version":null,"tagName":"h3"},{"title":"OnQuestObjectiveChanged​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#OnQuestObjectiveChanged","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.OnQuestObjectiveChanged: Signal Called when one of the quest's objective gets changed local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnQuestObjectiveChanged:Connect(function(player: Player, questId: string, objectiveId: string, newValue: number) self:UpdateObjective(RoQuest:GetQuest(player, questId), objectiveId, newValue) end)   ","version":null,"tagName":"h3"},{"title":"OnQuestStarted​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#OnQuestStarted","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.OnQuestStarted: Signal Called whenever the player starts a new quest! local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnQuestStarted:Connect(function(player: Player, questId: string) print(&quot;Player has started the quest: &quot;, RoQuest:GetQuest(player, questId).Name) end)   ","version":null,"tagName":"h3"},{"title":"OnQuestCompleted​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#OnQuestCompleted","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.OnQuestCompleted: Signal Called whenever the player completes a quest! local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnQuestCompleted:Connect(function(player: Player, questId: string) print(&quot;Player has completed the quest: &quot;, RoQuest:GetQuest(player, questId).Name) end)   ","version":null,"tagName":"h3"},{"title":"OnQuestDelivered​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#OnQuestDelivered","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.OnQuestDelivered: Signal Called whenever the player delivers a quest! local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnQuestDelivered:Connect(function(player: Player, questId: string) print(&quot;Player has delivered the quest: &quot;, RoQuest:GetQuest(player, questId).Name) end)   ","version":null,"tagName":"h3"},{"title":"OnQuestCancelled​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#OnQuestCancelled","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.OnQuestCancelled: Signal Called whenever a quest gets cancelled. This might happen when a player asks to cancel a quest or the developer disables a quest at run-time (per example when an event finishes) local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnQuestCancelled:Connect(function(player: Player, questId: string) print(&quot;The following quest just got removed: &quot;, RoQuest:GetQuest(player, questId).Name) end)   ","version":null,"tagName":"h3"},{"title":"OnTimeQuestAvailable​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#OnTimeQuestAvailable","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.OnTimeQuestAvailable: Signal This gets called when a quest becomes available. This isn't player specific and instead gets called when per e.g a quest with a starting and end date becomes available local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnTimeQuestAvailable:Connect(function(questId: string) print(&quot;The following quest just became available: &quot;, RoQuest:GetQuest(player, questId).Name) end)   ","version":null,"tagName":"h3"},{"title":"OnTimeQuestUnavailable​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#OnTimeQuestUnavailable","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.OnTimeQuestUnavailable: Signal This gets called when a quest becomes unavailable. This isn't player specific and instead gets called when per e.g a quest with a starting and end date becomes unavailable local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnTimeQuestUnavailable:Connect(function(questId: string) print(&quot;The following quest just became unavailable: &quot;, RoQuest:GetQuest(player, questId).Name) end)   ","version":null,"tagName":"h3"},{"title":"OnQuestAvailable​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#OnQuestAvailable","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.OnQuestAvailable: Signal This gets called when a quest becomes available. This usually means that the player can now accept this quest at a given quest giver local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnQuestAvailable:Connect(function(player: Player, questId: string) print(&quot;The following quest just became available: &quot;, RoQuest:GetQuest(player, questId).Name) end)   ","version":null,"tagName":"h3"},{"title":"OnQuestUnavailable​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#OnQuestUnavailable","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.OnQuestUnavailable: Signal This gets called when a quest becomes unavailable. Usually only happens when a quest gets disabled at run-time or when the quest's end time has passed local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnQuestUnavailable:Connect(function(player: Player, questId: string) print(&quot;The player's quest has just been cancelled: &quot;, RoQuest:GetStaticQuest(questId).Name) end)   ","version":null,"tagName":"h3"},{"title":"OnUnAvailableQuestChanged​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#OnUnAvailableQuestChanged","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.OnUnAvailableQuestChanged: Signal This gets called whenever the quests that are unavailable changes. This means that either a quest just became available OR that a quest became unavailable (such as a quest with an end time) local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnUnAvailableQuestChanged:Connect(function(player: Player) print(self:GetUnAvailableQuests(player)) end)   ","version":null,"tagName":"h3"},{"title":"OnAvailableQuestChanged​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#OnAvailableQuestChanged","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.OnAvailableQuestChanged: Signal This gets called whenever the quests that are available changes. Called when one of the available quests becomes unavailable or when a quest gets started by the player local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnAvailableQuestChanged:Connect(function(player: Player) print(self:GetAvailableQuests(player)) end)   ","version":null,"tagName":"h3"},{"title":"OnCompletedQuestChanged​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#OnCompletedQuestChanged","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.OnCompletedQuestChanged: Signal This gets called whenever the quests that are completed changes. This gets called when either a quest got delivered, a quest just got completed or somehow the quest got cancelled while completed local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnCompletedQuestChanged:Connect(function(player: Player) print(self:GetCompletedQuests(player)) end)   ","version":null,"tagName":"h3"},{"title":"OnDeliveredQuestChanged​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#OnDeliveredQuestChanged","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.OnDeliveredQuestChanged: Signal This gets called whenever the quests that are delivered changes. This gets called when either a quest got delivered or a delivered quest gets restarted local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnDeliveredQuestChanged:Connect(function(player: Player) print(self:GetDeliveredQuests(player)) end)   ","version":null,"tagName":"h3"},{"title":"OnInProgressQuestChanged​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#OnInProgressQuestChanged","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.OnInProgressQuestChanged: Signal This gets called whenever the quests that are in progress change. This gets called when either a quest got completed or started by the player local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnInProgressQuestChanged:Connect(function(player: Player) print(self:GetInProgressQuests(player)) end)   ","version":null,"tagName":"h3"},{"title":"PlayerQuestData​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#PlayerQuestData","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.PlayerQuestData: PlayerQuestData This is a reference to our PlayerQuestData struct  ","version":null,"tagName":"h3"},{"title":"Quest​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#Quest","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.Quest: Quest This is a reference to our Quest class  ","version":null,"tagName":"h3"},{"title":"QuestLifeCycle​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#QuestLifeCycle","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.QuestLifeCycle: QuestLifeCycle This is a reference to our QuestLifeCycle class  ","version":null,"tagName":"h3"},{"title":"ObjectiveInfo​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#ObjectiveInfo","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.ObjectiveInfo: ObjectiveInfo This is a reference to our ObjectiveInfo class  ","version":null,"tagName":"h3"},{"title":"QuestAcceptType​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#QuestAcceptType","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.QuestAcceptType: QuestAcceptType This is a reference to our QuestAcceptType enum  ","version":null,"tagName":"h3"},{"title":"QuestDeliverType​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#QuestDeliverType","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.QuestDeliverType: QuestDeliverType This is a reference to our QuestDeliverType enum  ","version":null,"tagName":"h3"},{"title":"QuestRepeatableType​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#QuestRepeatableType","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.QuestRepeatableType: QuestRepeatableType This is a reference to our QuestRepeatableType enum  ","version":null,"tagName":"h3"},{"title":"QuestStatus​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#QuestStatus","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.QuestStatus: QuestStatus This is a reference to our QuestStatus enum ","version":null,"tagName":"h3"},{"title":"Functions​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#functions","content":" ","version":null,"tagName":"h2"},{"title":"OnStart​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#OnStart","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer.OnStart() → Promise This is one of the most important methods of this Module. It is used to ensure that your code is only called after the RoQuestServer has been initiated. It is safe to get player data and quest data after this method has been called local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest.OnStart():andThen(function() print(&quot;RoQuestServer has been initiated!&quot;) RoQuest.OnQuestStarted:Connect(function(player: Player, questId: string) print(player.Name, &quot;has just started the quest: &quot;, RoQuest:GetStaticQuest(questId).Name, &quot;!&quot;) end) RoQuest.OnQuestCompleted:Connect(function(player: Player, questId: string) print(player.Name, &quot;has just completed the quest: &quot;, RoQuest:GetStaticQuest(questId).Name, &quot;!&quot;) end) end)   ","version":null,"tagName":"h3"},{"title":"Init​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#Init","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:Init( quests: {Quest}, lifeCycles: {QuestLifeCycle}? ) → ()  INFO This function should only get called once in the server-side. It will initialize our quest system and start listening to player events Initiates our quest system and feeds it all the data about the quests and lifecycles local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest:Init(RoQuest:LoadDirectory(ReplicatedStorage.Quests))   ","version":null,"tagName":"h3"},{"title":"LoadDirectory​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#LoadDirectory","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:LoadDirectory(directory: {Instance }) → {Quest | QuestLifeCycle}-- Returns an array with either just Quests or QuestLifeCycles Loads all the quests and lifecycles right under the given director and returns them in an array local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest:Init(RoQuest:LoadDirectory(ReplicatedStorage.Quests))   ","version":null,"tagName":"h3"},{"title":"LoadDirectoryDeep​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#LoadDirectoryDeep","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:LoadDirectoryDeep(directory: {Instance }) → {Quest | QuestLifeCycle}-- Returns an array with either just Quests or QuestLifeCycles Loads all the quests and lifecycles from the descendants of the directory and returns them in an array. The difference from :LoadDirectoryDeep and :LoadDirectory is that this one takes all descendants into account instead of just the children local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server RoQuest:Init(RoQuest:LoadDirectoryDeep(ReplicatedStorage.Quests))   ","version":null,"tagName":"h3"},{"title":"GetStaticQuest​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#GetStaticQuest","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:GetStaticQuest(questId: string) → Quest? Gets the static data of a cached quest by the given ID local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server local quest: Quest = RoQuest:GetStaticQuest(&quot;QuestId&quot;)   ","version":null,"tagName":"h3"},{"title":"GetAvailableStaticQuests​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#GetAvailableStaticQuests","content":"&lt;/&gt; RoQuestServer:GetAvailableStaticQuests() → {[string]: Quest} Gets all the available static quests local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server local quest: {[string]: Quest} = RoQuest:GetAvailableStaticQuests()   ","version":null,"tagName":"h3"},{"title":"GetStaticQuests​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#GetStaticQuests","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:GetStaticQuests() → {[string]: Quest}-- &lt;questId: string, quest: Quest&gt; Gets the static data of all of the cached quests local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server local quests: {[string]: Quest} = RoQuest:GetStaticQuests()   ","version":null,"tagName":"h3"},{"title":"GetQuest​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#GetQuest","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:GetQuest( player: Player , questId: string ) → Quest?  INFO This function returns a quest object if the status of the quest is InProgress, Completed or Delivered Gets a player quest object. It will return nil if the player has never started the quest! local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... local quest: Quest? = RoQuest:GetQuest(player, &quot;QuestId&quot;) --...   ","version":null,"tagName":"h3"},{"title":"GetQuests​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#GetQuests","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:GetQuests(player: Player ) → {[string]: Quest}-- &lt;questId: string, quest: Quest&gt;  INFO This function returns all the quests of the status of the quest is InProgress, Completed or Delivered Returns all the quests of the given player local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... local quests: {[string]: Quest} = RoQuest:GetQuests(player) --...   ","version":null,"tagName":"h3"},{"title":"GetCompletedQuests​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#GetCompletedQuests","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:GetCompletedQuests( player: Player -- The player that owns all the quests ) → {[string]: Quest}-- &lt;questId: string, quest: Quest&gt; Gets all the completed quests by the given player local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... local completedQuests: {[string]: Quest} = RoQuest:GetCompletedQuests(player) print(completeQuests) -- {QuestId = QuestObject, QuestId2 = QuestObject2, ...} --...   ","version":null,"tagName":"h3"},{"title":"GetDeliveredQuests​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#GetDeliveredQuests","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:GetDeliveredQuests( player: Player -- The player that owns all the quests ) → {[string]: Quest}-- &lt;questId: string, quest: Quest&gt; Gets all the delivered quests by the given player local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... local deliveredQuests: {[string]: Quest} = RoQuest:GetDeliveredQuests(player) print(deliveredQuests) -- {QuestId = QuestObject, QuestId2 = QuestObject2, ...} --...   ","version":null,"tagName":"h3"},{"title":"GetInProgressQuests​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#GetInProgressQuests","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:GetInProgressQuests( player: Player -- The player that owns all the quests ) → {[string]: Quest}-- &lt;questId: string, quest: Quest&gt; Gets all the quests that are in progress by the given player local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... local questsInProgress: {[string]: Quest} = RoQuest:GetInProgressQuests(player) print(questsInProgress) -- {QuestId = QuestObject, QuestId2 = QuestObject2, ...} --...   ","version":null,"tagName":"h3"},{"title":"GetAvailableQuests​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#GetAvailableQuests","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:GetAvailableQuests( player: Player -- The player that owns all the quests ) → {[string]: Quest}-- &lt;questId: string, quest: Quest&gt; Gets all the quests that are available to the player. This means that the player can start the quest local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... local availableQuests: {[string]: Quest} = RoQuest:GetAvailableQuests(player) print(availableQuests) -- {QuestId = QuestObject, QuestId2 = QuestObject2, ...} --...   ","version":null,"tagName":"h3"},{"title":"GetUnAvailableQuests​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#GetUnAvailableQuests","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:GetUnAvailableQuests( player: Player -- The player that owns all the quests ) → {[string]: Quest}-- &lt;questId: string, quest: Quest&gt; Gets all the quests that are unavailable to the player. This means that the player can't start the quest local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... local unavailableQuests: {[string]: Quest} = RoQuest:GetUnAvailableQuests(player) print(unavailableQuests) -- {QuestId = QuestObject, QuestId2 = QuestObject2, ...} --...   ","version":null,"tagName":"h3"},{"title":"SetPlayerData​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#SetPlayerData","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:SetPlayerData( player: Player , data: PlayerQuestData ) → () Sets the player data. This will overwrite the current player data with the given data WARNING This should only be used when loading a player. It should be avoided at all costs unless completely necessary local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... RoQuest:SetPlayerData(player, playerQuestData) --...   ","version":null,"tagName":"h3"},{"title":"GetPlayerData​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#GetPlayerData","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:GetPlayerData(player: Player ) → PlayerQuestData Gets the player data. This is how we are capable of retreiving data to use when storing it to a DataStore local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... local playerData: PlayerQuestData = RoQuest:GetPlayerData(player) --...   ","version":null,"tagName":"h3"},{"title":"GetObjective​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#GetObjective","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:GetObjective( player: Player ,-- The player that owns the quest questId: string,-- The ID of our objective objectiveId: string ) → number Gets the current value of the quest's objective. This will return 0 if the quest doesn't exist local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... local objectiveValue: number = RoQuest:GetObjective(player, &quot;QuestId&quot;, &quot;ObjectiveId&quot;) --...   ","version":null,"tagName":"h3"},{"title":"AddObjective​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#AddObjective","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:AddObjective( player: Player ,-- The player that owns the quests objectiveId: string,-- The ID of our objective amount: number-- The amount we want to increment to the objective of our quests ) → () Adds X amount from all the quests that contain the given objective ID local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... RoQuest:AddObjective(player, &quot;ObjectiveId&quot;, 5) --...   ","version":null,"tagName":"h3"},{"title":"SetObjective​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#SetObjective","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:SetObjective( player: Player ,-- The player that owns the quests objectiveId: string,-- The ID of our objective amount: number-- The amount to which the objective should be set to ) → () Sets all the quests that contain the given objective ID to the given amount local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... RoQuest:GetObjective(player, &quot;questId&quot;, &quot;ObjectiveId&quot;) -- 0 RoQuest:SetObjective(player, &quot;ObjectiveId&quot;, 5) RoQuest:GetObjective(player, &quot;questId&quot;, &quot;ObjectiveId&quot;) -- 5 --...   ","version":null,"tagName":"h3"},{"title":"RemoveObjective​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#RemoveObjective","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:RemoveObjective( player: Player ,-- The player that owns the quests objectiveId: string,-- The ID of our objective amount: number-- The amount we want to decrement to the objective of our quests ) → () Removes X amount from all the quests that contain the given objective ID local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... RoQuest:RemoveObjective(player, &quot;ObjectiveId&quot;, 5) --...   ","version":null,"tagName":"h3"},{"title":"GiveQuest​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#GiveQuest","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:GiveQuest( player: Player , questId: string ) → boolean-- If it managed to give the player the quest or not Gives the quest to the player for him to start. Usually used when quests are set to manual mode local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... RoQuest:GiveQuest(player, &quot;QuestId&quot;) --...   ","version":null,"tagName":"h3"},{"title":"CompleteQuest​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#CompleteQuest","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:CompleteQuest( player: Player , questId: string ) → boolean-- If it managed to complete the quest or not Completes the quest of a player instantly. This will not deliver the quest unless deliver is set to automatically local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... RoQuest:CompleteQuest(player, &quot;QuestId&quot;) --...   ","version":null,"tagName":"h3"},{"title":"DeliverQuest​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#DeliverQuest","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:DeliverQuest( player: Player , questId: string ) → boolean-- If it managed to deliver the quest or not Delivers the quest of a player local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... RoQuest:DeliverQuest(player, &quot;QuestId&quot;) --...   ","version":null,"tagName":"h3"},{"title":"CancelQuest​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#CancelQuest","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:CancelQuest( player: Player , questId: string ) → boolean-- If it managed to cancel the quest or not Cancels the quest of a player. This will remove the quest from the player's cache local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server --... RoQuest:CancelQuest(player, &quot;QuestId&quot;) --...   ","version":null,"tagName":"h3"},{"title":"CanGiveQuest​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#CanGiveQuest","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:CanGiveQuest( player: Player , questId: string ) → boolean-- If the player can accept the quest or not Checks if the player can or not accept the quest local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server local player: Player = game.Players:GetPlayers()[1] if RoQuest:CanGiveQuest(player, &quot;QuestId&quot;) then print(&quot;Player can accept the quest!&quot;) else print(&quot;Player can't accept the quest!&quot;) end   ","version":null,"tagName":"h3"},{"title":"MakeQuestAvailable​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#MakeQuestAvailable","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:MakeQuestAvailable( player: Player , questId: string ) → ()  WARNING This can only be called if the quest repeatable type is set to Custom  ","version":null,"tagName":"h3"},{"title":"GetQuestStatus​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#GetQuestStatus","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:GetQuestStatus( player: Player , questId: string ) → QuestStatus Get the quest status  ","version":null,"tagName":"h3"},{"title":"GetLifeCycle​","type":1,"pageTitle":"RoQuestServer","url":"/RoQuest/api/RoQuestServer#GetLifeCycle","content":"This item only works when running on the server. Server &lt;/&gt; RoQuestServer:GetLifeCycle( player: Player , questId: string, lifeCycleName: string ) → QuestLifeCycle? Gets a lifecycle object from a quest by the name ","version":null,"tagName":"h3"},{"title":"⛓️ My First Quest Chain","type":0,"sectionRef":"#","url":"/RoQuest/docs/MyFirstQuestChain","content":"","keywords":"","version":"Next"},{"title":"❓ What is a quest chain?​","type":1,"pageTitle":"⛓️ My First Quest Chain","url":"/RoQuest/docs/MyFirstQuestChain#-what-is-a-quest-chain","content":" A quest chain as the name indicates is when we have a sequence of quests. This means that the player needs to deliver a quest before being allowed to move into the next one!  We'll make an example one with the apple quest that we have done in the earlier sections! Make sure to check My First Quest if you haven't already!  ","version":"Next","tagName":"h2"},{"title":"🏹 Our second quest​","type":1,"pageTitle":"⛓️ My First Quest Chain","url":"/RoQuest/docs/MyFirstQuestChain#-our-second-quest","content":" Let's make a quest just like the previous one but instead of 2 apples we'll need 5 apples to complete!  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server local appleObjective = require(ReplicatedStorage.QuestObjectives.AppleInfo) local Quest = RoQuest.Quest return Quest { Name = &quot;Collect Apples&quot;, -- The name of our quest Description = &quot;Collect 5 apples&quot;, -- The description that we will display to our user QuestId = &quot;AppleCollection2&quot;, -- A unique identifier to our quest QuestAcceptType = RoQuest.QuestAcceptType.Automatic, -- If the quest automatically gets accepted or rquires manual work QuestDeliverType = RoQuest.QuestDeliverType.Automatic, -- If the quest automatically gets delivered or requires manual work QuestRepeatableType = RoQuest.QuestRepeatableType.NonRepeatable, -- If the quest can be repeated or not QuestStart = -1, -- UTC time to define when the quest should become available (specially useful for event quests) QuestEnd = -1, -- UTC time to define when the quest should no longer be available (specially useful for event quests) RequiredQuests = {}, -- A list of quests that are required to be delivered before this quest can be started LifeCycles = {}, -- The lifecycles that will manage this quest's behavior QuestObjectives = { appleObjective:NewObjective(5) }, }   Don't forget to change the QuestID if you're copy pasting the previous quest!  ","version":"Next","tagName":"h2"},{"title":"⛓️ Chaining quest​","type":1,"pageTitle":"⛓️ My First Quest Chain","url":"/RoQuest/docs/MyFirstQuestChain#️-chaining-quest","content":" Now that we chained the quest ensure it is connected to the previous quest by adding the ID from the previous quest to the &quot;RequiredQuests&quot; property!  return Quest { Name = &quot;Collect Apples&quot;, -- The name of our quest Description = &quot;Collect 5 apples&quot;, -- The description that we will display to our user QuestId = &quot;AppleCollection2&quot;, -- A unique identifier to our quest QuestAcceptType = RoQuest.QuestAcceptType.Automatic, -- If the quest automatically gets accepted or rquires manual work QuestDeliverType = RoQuest.QuestDeliverType.Automatic, -- If the quest automatically gets delivered or requires manual work QuestRepeatableType = RoQuest.QuestRepeatableType.NonRepeatable, -- If the quest can be repeated or not QuestStart = -1, -- UTC time to define when the quest should become available (specially useful for event quests) QuestEnd = -1, -- UTC time to define when the quest should no longer be available (specially useful for event quests) RequiredQuests = {&quot;AppleCollection&quot;}, -- A list of quests that are required to be delivered before this quest can be started LifeCycles = {}, -- The lifecycles that will manage this quest's behavior QuestObjectives = { appleObjective:NewObjective(5) }, }   Now hop in the play test and give it a try! ","version":"Next","tagName":"h2"},{"title":"🖥️ Making Quest UI","type":0,"sectionRef":"#","url":"/RoQuest/docs/MyFirstUI/MakingQuestUI","content":"","keywords":"","version":"Next"},{"title":"🖥️ Import UI​","type":1,"pageTitle":"🖥️ Making Quest UI","url":"/RoQuest/docs/MyFirstUI/MakingQuestUI#️-import-ui","content":" In order to make this tutorial easier to follow I'll provide some assets to create our first UI! Please install them here and import them into your StarterGui:  https://create.roblox.com/store/asset/17477286969    ","version":"Next","tagName":"h2"},{"title":"👀 Example​","type":1,"pageTitle":"🖥️ Making Quest UI","url":"/RoQuest/docs/MyFirstUI/MakingQuestUI#-example","content":" local Players = game:GetService(&quot;Players&quot;) local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client type Quest = RoQuest.Quest type QuestObjective = RoQuest.QuestObjective local QuestStatus = RoQuest.QuestStatus local localPlayer: Player = Players.LocalPlayer local playerGui: PlayerGui = localPlayer:WaitForChild(&quot;PlayerGui&quot;) local scrollingFrame: ScrollingFrame = playerGui:WaitForChild(&quot;Quests&quot;):WaitForChild(&quot;Main&quot;):WaitForChild(&quot;ScrollingFrame&quot;) local template: Frame = scrollingFrame:WaitForChild(&quot;Template&quot;) local clone = template:Clone() template:Destroy() template = clone local Quests = {} function Quests:UpdateObjective(quest: Quest, objectiveId: string, newValue: number) local existingFrame: Frame? = scrollingFrame:FindFirstChild(quest.QuestId) if not existingFrame then return end local objectivesWindow: Frame = existingFrame.TextContainer.Objectives local objectiveText: TextLabel? = objectivesWindow:FindFirstChild(objectiveId) if not objectiveText then return end local questObjective: QuestObjective = quest:GetQuestObjective(objectiveId) objectiveText.Text = string.format(questObjective:GetDescription(), newValue, questObjective:GetTargetProgress()) end function Quests:UpdateQuestFrame(quest: Quest, frame: Frame) local textContainer: Frame = frame:WaitForChild(&quot;TextContainer&quot;) if quest:GetQuestStatus() == QuestStatus.Completed then textContainer.Description.Text = &quot;Read to deliver!&quot; elseif quest:GetQuestStatus() == QuestStatus.Delivered then frame:Destroy() else textContainer.Title.Text = quest.Name textContainer.Description.Text = quest.Description end end function Quests:UpdateInterface() local quests: {[string]: Quest} = RoQuest:GetInProgressQuests() for _, instance: Instance in scrollingFrame:GetChildren() do -- Delete quests that dont exit if instance:IsA(&quot;Frame&quot;) and not quests[instance.Name] then instance:Destroy() end end for questId: string, quest: Quest in quests do local existingFrame: Frame = scrollingFrame:FindFirstChild(questId) if existingFrame then self:UpdateQuestFrame(quest, existingFrame) continue -- Quest already exists end local newTemplate: Frame = template:Clone() newTemplate.Name = questId local textContainer: Frame = newTemplate:WaitForChild(&quot;TextContainer&quot;) textContainer.Title.Text = quest.Name textContainer.Description.Text = quest.Description local objectives: Frame = textContainer:WaitForChild(&quot;Objectives&quot;) for _, questObjective: QuestObjective in quest:GetQuestObjectives() do local objectiveTemplate: TextLabel = textContainer.Description:Clone() objectiveTemplate.Name = questObjective:GetObjectiveId() objectiveTemplate.TextSize = 14 objectiveTemplate.Text = string.format(questObjective:GetDescription(), questObjective:Get(), questObjective:GetTargetProgress()) objectiveTemplate.Parent = objectives end newTemplate.Parent = scrollingFrame self:UpdateQuestFrame(quest, newTemplate) end end RoQuest.OnStart():andThen(function() RoQuest.OnInProgressQuestChanged:Connect(function() Quests:UpdateInterface() end) RoQuest.OnQuestObjectiveChanged:Connect(function(questId: string, objectiveId: string, newValue: number) Quests:UpdateObjective(RoQuest:GetQuest(questId), objectiveId, newValue) end) RoQuest.OnPlayerDataChanged:Connect(function() Quests:UpdateInterface() end) -- Hard reset our screens Quests:UpdateInterface() end)   The vast majority of this code was just actually setting up the interface UI yet the most important and relevant part is how we gained and updates the data with RoQuest so let's break it down!  ","version":"Next","tagName":"h2"},{"title":"📥 Getting Data​","type":1,"pageTitle":"🖥️ Making Quest UI","url":"/RoQuest/docs/MyFirstUI/MakingQuestUI#-getting-data","content":" In RoQuest you can get either all quests or all the quests with a specific state. In order to display the quests that are in progress an easy way to do that would be with the following method:  local quests: {[string]: Quest} = RoQuest:GetInProgressQuests()   This will return all the quests that are currently in progress  ","version":"Next","tagName":"h2"},{"title":"⚡ Listening to Data​","type":1,"pageTitle":"🖥️ Making Quest UI","url":"/RoQuest/docs/MyFirstUI/MakingQuestUI#-listening-to-data","content":" Once we have all of our data set we want to update teh UI under 2 circumstances: when either the data of the quests we're showing changes OR when the quests that are currently in progress change. To do that we can use these 3 events:  RoQuest.OnInProgressQuestChanged:Connect(function() Quests:UpdateInterface() end) RoQuest.OnQuestObjectiveChanged:Connect(function(questId: string, objectiveId: string, newValue: number) Quests:UpdateObjective(RoQuest:GetQuest(questId), objectiveId, newValue) end) RoQuest.OnPlayerDataChanged:Connect(function() Quests:UpdateInterface() end) -- Hard reset our screens   warning And just like we did on the server make sure that you only interact with RoQuest AFTER it loaded by using RoQuest.OnStart   ","version":"Next","tagName":"h2"},{"title":"📆 Custom","type":0,"sectionRef":"#","url":"/RoQuest/docs/RepeatableQuests/Custom","content":"","keywords":"","version":"Next"},{"title":"🧱 Create Part​","type":1,"pageTitle":"📆 Custom","url":"/RoQuest/docs/RepeatableQuests/Custom#-create-part","content":" First we'll be creating a part. We will use this part as a way to reset our players quest!    ","version":"Next","tagName":"h2"},{"title":"🗺️ Set Quest​","type":1,"pageTitle":"📆 Custom","url":"/RoQuest/docs/RepeatableQuests/Custom#️-set-quest","content":" Let's set the quest repeatable type to Custom  return Quest { Name = &quot;Collect Sticks&quot;, Description = &quot;Collect 3 sticks&quot;, QuestId = &quot;StickCollection&quot;, QuestAcceptType = RoQuest.QuestAcceptType.Automatic, QuestDeliverType = RoQuest.QuestDeliverType.Automatic, QuestRepeatableType = RoQuest.QuestRepeatableType.Custom, -- Set to Custom QuestStart = -1, QuestEnd = -1, RequiredQuests = {}, LifeCycles = {}, QuestObjectives = { stickObjective:NewObjective(3) }, }   ","version":"Next","tagName":"h2"},{"title":"🧹 Reset Quest​","type":1,"pageTitle":"📆 Custom","url":"/RoQuest/docs/RepeatableQuests/Custom#-reset-quest","content":" Now let's write some code to allow us to reset the quest status!  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server local part = workspace:WaitForChild(&quot;QuestReset&quot;) local proximityPrompt = Instance.new(&quot;ProximityPrompt&quot;) proximityPrompt.ActionText = &quot;Quest Reset&quot; proximityPrompt.Parent = part proximityPrompt.Triggered:Connect(function(player) RoQuest:MakeQuestAvailable(player, &quot;StickCollection&quot;) end)   Using the RoQuest:MakeQuestAvailable(player, &quot;StickCollection&quot;) we're capable of resetting a quest status to available! ","version":"Next","tagName":"h2"},{"title":"📅 Daily/Weekly","type":0,"sectionRef":"#","url":"/RoQuest/docs/RepeatableQuests/Daily","content":"📅 Daily/Weekly RoQuest by default provides support for daily and weekly quests. These are quests you can do either once a day or once a week! All you have to do is set the QuestRepeatableType to either Weekly or Daily return Quest { QuestRepeatableType = RoQuest.QuestRepeatableType.Daily } ","keywords":"","version":"Next"},{"title":"🚫 Disable Quests","type":0,"sectionRef":"#","url":"/RoQuest/docs/Tips/DisableQuests","content":"🚫 Disable Quests We can disable quests from being loaded into the quest system by simple adding a Disable property to our quests Quest { Disabled = true } ","keywords":"","version":"Next"},{"title":"📜 Making a Quest Log","type":0,"sectionRef":"#","url":"/RoQuest/docs/MyFirstUI/QuestLog","content":"","keywords":"","version":"Next"},{"title":"👀 Example​","type":1,"pageTitle":"📜 Making a Quest Log","url":"/RoQuest/docs/MyFirstUI/QuestLog#-example","content":" --Hud.lua --!strict local Players = game:GetService(&quot;Players&quot;) local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client local localPlayer: Player = Players.LocalPlayer local playerGui = localPlayer:WaitForChild(&quot;PlayerGui&quot;) local questLog = playerGui:WaitForChild(&quot;QuestLog&quot;) local hud = playerGui:WaitForChild(&quot;HUD&quot;) local screens = { QuestLog = questLog.Container, } local Hud = {} Hud.currentScreen = &quot;&quot; function Hud:DisableScreen(screenName: string) if not screens[screenName] then return end screens[screenName].Visible = false self.currentScreen = &quot;&quot; end function Hud:EnableScreen(screenName: string) local currentScreen = self.currentScreen self:DisableScreen(self.currentScreen) if screenName == currentScreen then return end screens[screenName].Visible = true self.currentScreen = screenName end RoQuest.OnStart():andThen(function() for _, instance: Instance in hud.Container:GetChildren() do if not instance:IsA(&quot;ImageButton&quot;) then continue end (instance :: ImageButton).Activated:Connect(function() Hud:EnableScreen(instance.Name) end) end end)   --QuestLog.lua  local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local Players = game:GetService(&quot;Players&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Client local Red = require(ReplicatedStorage.RoQuest.Vendor.Red).Client type Quest = RoQuest.Quest local DEFAULT_COLOR: Color3 = Color3.fromRGB(140, 140, 140) local ACTIVE_COLOR: Color3 = Color3.fromRGB(255, 255, 127) local localPlayer: Player = Players.LocalPlayer local playerGui: PlayerGui = localPlayer:WaitForChild(&quot;PlayerGui&quot;) local questLog: ScreenGui = playerGui:WaitForChild(&quot;QuestLog&quot;) local template: Frame = questLog.Container.Unavailable.Template:Clone() questLog.Container.Unavailable.Template:Destroy() -- Delete the template after we cached a clone local QuestLog = {} QuestLog.screens = {} :: {[string]: ScrollingFrame} QuestLog.buttons = {} :: {[string]: GuiButton} QuestLog.currentScreen = &quot;&quot; :: string function QuestLog:UpdateButtonColor() for buttonName: string, button: GuiButton in self.buttons do button.BackgroundColor3 = buttonName == self.currentScreen and ACTIVE_COLOR or DEFAULT_COLOR end end function QuestLog:SetScreen(name: string) if self.currentScreen == name then return end local currentScrollingFrame: ScrollingFrame? = self.screens[self.currentScreen] local newScrollingFrame: ScrollingFrame? = self.screens[name] if currentScrollingFrame then currentScrollingFrame.Visible = false end if newScrollingFrame then newScrollingFrame.Visible = true end self.currentScreen = name self:UpdateButtonColor() end function QuestLog:SetupButtons() for _, button: Instance in questLog.Container.Buttons:GetChildren() do if not button:IsA(&quot;GuiButton&quot;) then continue end (button :: GuiButton).Activated:Connect(function() self:SetScreen(button.Name) end) self.buttons[button.Name] = button end end function QuestLog:SetupWindows() for _, child: Instance in questLog.Container:GetChildren() do if not child:IsA(&quot;ScrollingFrame&quot;) then continue end self.screens[child.Name] = child end end function QuestLog:DestroyQuest(scrollingFrame: ScrollingFrame, questId: string) local frame: Frame? = scrollingFrame:FindFirstChild(questId) if frame then frame:Destroy() end end function QuestLog:CreateQuest(scrollingFrame: ScrollingFrame, quest: Quest) local Net = Red &quot;QuestManager&quot; local frame: Frame = scrollingFrame:FindFirstChild(quest.QuestId) or template:Clone() frame.Name = quest.QuestId frame.Title.Text = quest.Name frame.Description.Text = quest.Description frame.Buttons.Cancel.Visible = quest:GetQuestStatus() == RoQuest.QuestStatus.InProgress frame.Buttons.Cancel.Activated:Connect(function() Net:Fire(&quot;CancelQuest&quot;, quest.QuestId) end) frame.Visible = true frame.Parent = scrollingFrame end function QuestLog:PopulateScreen(scrollingFrame: ScrollingFrame, quests: {[string]: Quest}) for _, child: Instance in scrollingFrame:GetChildren() do -- Remove quests no longer in use if not child:IsA(&quot;Frame&quot;) then continue end if not quests[child.Name] then child:Destroy() end end for _, quest: Quest in quests do self:CreateQuest(scrollingFrame, quest) end end function QuestLog:SetAllScreens() self:PopulateScreen(self.screens[&quot;InProgress&quot;], RoQuest:GetInProgressQuests()) self:PopulateScreen(self.screens[&quot;Available&quot;], RoQuest:GetAvailableQuests()) self:PopulateScreen(self.screens[&quot;Completed&quot;], RoQuest:GetCompletedQuests()) self:PopulateScreen(self.screens[&quot;Delivered&quot;], RoQuest:GetDeliveredQuests()) self:PopulateScreen(self.screens[&quot;Unavailable&quot;], RoQuest:GetUnAvailableQuests()) end RoQuest.OnStart():andThen(function() QuestLog:SetupWindows() -- Caching our windows QuestLog:SetupButtons() -- Caching our buttons QuestLog:SetScreen(&quot;InProgress&quot;) -- Setting the initial active screen QuestLog:SetAllScreens() -- Populating all screens RoQuest.OnUnAvailableQuestChanged:Connect(function() QuestLog:PopulateScreen(QuestLog.screens[&quot;Unavailable&quot;], RoQuest:GetUnAvailableQuests()) end) RoQuest.OnAvailableQuestChanged:Connect(function() QuestLog:PopulateScreen(QuestLog.screens[&quot;Available&quot;], RoQuest:GetAvailableQuests()) end) RoQuest.OnCompletedQuestChanged:Connect(function() QuestLog:PopulateScreen(QuestLog.screens[&quot;Completed&quot;], RoQuest:GetCompletedQuests()) end) RoQuest.OnDeliveredQuestChanged:Connect(function() QuestLog:PopulateScreen(QuestLog.screens[&quot;Delivered&quot;], RoQuest:GetDeliveredQuests()) end) RoQuest.OnInProgressQuestChanged:Connect(function() QuestLog:PopulateScreen(QuestLog.screens[&quot;InProgress&quot;], RoQuest:GetInProgressQuests()) end) RoQuest.OnPlayerDataChanged:Connect(function() QuestLog:SetAllScreens() end) -- Hard reset our screens end)   ","version":"Next","tagName":"h2"},{"title":"🔑 Main take aways​","type":1,"pageTitle":"📜 Making a Quest Log","url":"/RoQuest/docs/MyFirstUI/QuestLog#-main-take-aways","content":" We used multiple events from RoQuest to listen to the changes from specific quest states. We also used different quest getters to get the information from said quests.  info You should always have a listener for when the player data changes that resets everything. This ensure that if a player's data gets hard reset that you can update the interface accordingly. RoQuest.OnPlayerDataChanged:Connect(function() QuestLog:SetAllScreens() end) -- Hard reset our screens  ","version":"Next","tagName":"h2"},{"title":"♾️ Infinite","type":0,"sectionRef":"#","url":"/RoQuest/docs/RepeatableQuests/Infinite","content":"","keywords":"","version":"Next"},{"title":"🪵 Creating Sticks​","type":1,"pageTitle":"♾️ Infinite","url":"/RoQuest/docs/RepeatableQuests/Infinite#-creating-sticks","content":" Let's create some sticks and tag them all with a tag called &quot;Stick&quot;    ","version":"Next","tagName":"h2"},{"title":"💻 Code​","type":1,"pageTitle":"♾️ Infinite","url":"/RoQuest/docs/RepeatableQuests/Infinite#-code","content":" Great! Now that we have some sticks let's create a new script under ServerScriptService and add the following code:  ","version":"Next","tagName":"h2"},{"title":"🪵 Make Sticks collectible​","type":1,"pageTitle":"♾️ Infinite","url":"/RoQuest/docs/RepeatableQuests/Infinite#-make-sticks-collectible","content":" Now that we created the sticks we want to make them collectible. For that you can use the following example code:  --Sticks.lua local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local CollectionService = game:GetService(&quot;CollectionService&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server local function stickAdded(stick) local clone = stick:Clone() local proximityPrompt = Instance.new(&quot;ProximityPrompt&quot;) proximityPrompt.ActionText = &quot;Collect Stick&quot; proximityPrompt.HoldDuration = 0.25 proximityPrompt.Triggered:Connect(function(player) stick:Destroy() RoQuest:AddObjective(player, &quot;Stick&quot;, 1) -- Add to the quest task.delay(5, function() -- Respawn after 5 seconds clone.Parent = workspace end) end) proximityPrompt.Parent = stick end CollectionService:GetInstanceAddedSignal(&quot;Stick&quot;):Connect(stickAdded) for _, stick in CollectionService:GetTagged(&quot;Stick&quot;) do stickAdded(stick) end   The main take-away from here is the following function:  RoQuest:AddObjective(player, &quot;Stick&quot;, 1)  What this function does is tell our quest system that hey the player just collected a stick  ","version":"Next","tagName":"h3"},{"title":"🎯 Create Quest Objective​","type":1,"pageTitle":"♾️ Infinite","url":"/RoQuest/docs/RepeatableQuests/Infinite#-create-quest-objective","content":" Now we need to create the actual quest. To create the actual quest we first need to make the objective required to complete this quest. I'd recommend creating this under ReplicatedStorage in its own folder for quest objectives. Here's an example:  -- StickInfo.lua local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server local ObjectiveInfo = RoQuest.ObjectiveInfo return ObjectiveInfo.new { Description = &quot;%s/%s sticks collected&quot;, Name = &quot;Collect Sticks&quot;, ObjectiveId = &quot;Stick&quot;, }   ","version":"Next","tagName":"h3"},{"title":"📜 Create Quest​","type":1,"pageTitle":"♾️ Infinite","url":"/RoQuest/docs/RepeatableQuests/Infinite#-create-quest","content":" And finally we need to create the actual quest object! For this let's make this:  -- Stick.lua local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local RoQuest = require(ReplicatedStorage.RoQuest).Server local stickObjective = require(ReplicatedStorage.QuestObjectives.StickInfo) local Quest = RoQuest.Quest return Quest { Name = &quot;Collect Sticks&quot;, -- The name of our quest Description = &quot;Collect 3 sticks&quot;, -- The description that we will display to our user QuestId = &quot;StickCollection&quot;, -- A unique identifier to our quest QuestAcceptType = RoQuest.QuestAcceptType.Automatic, -- If the quest automatically gets accepted or rquires manual work QuestDeliverType = RoQuest.QuestDeliverType.Automatic, -- If the quest automatically gets delivered or requires manual work QuestRepeatableType = RoQuest.QuestRepeatableType.Infinite, -- If the quest can be repeated or not QuestStart = -1, -- UTC time to define when the quest should become available (specially useful for event quests) QuestEnd = -1, -- UTC time to define when the quest should no longer be available (specially useful for event quests) RequiredQuests = {}, -- A list of quests that are required to be delivered before this quest can be started LifeCycles = {}, -- The lifecycles that will manage this quest's behavior QuestObjectives = { stickObjective:NewObjective(3) }, }   Please notice that we set the QuestRepeatableType to Infinite. Now if you hop into the game you can see you can complete this quest an infinite amount of times! ","version":"Next","tagName":"h3"},{"title":"⏳ Temporary Quests","type":0,"sectionRef":"#","url":"/RoQuest/docs/TemporaryQuests","content":"⏳ Temporary Quests Imagine temporary quests as event quests that you're adding to your game! You can set a starting date and an end date! This means the player can only access this quest, complete, and deliver it during this time period. To create a temporary quest all you have to do is modify the QuestStart and QuestEnd. These dates should be in UTC format. You can create your own UTC timers here: https://www.epochconverter.com/. Example of a quest a player can only complete in the first 60 seconds of a new server! return Quest { Name = &quot;Collect Sticks&quot;, Description = &quot;Collect 3 sticks&quot;, QuestId = &quot;StickCollection&quot;, QuestAcceptType = RoQuest.QuestAcceptType.Automatic, QuestDeliverType = RoQuest.QuestDeliverType.Automatic, QuestRepeatableType = RoQuest.QuestRepeatableType.Custom, -- If the quest can be repeated or not QuestStart = os.time(), -- UTC time to define when the quest should become available QuestEnd = os.time() + 60, -- UTC time to define when the quest should no longer be available QuestObjectives = { stickObjective:NewObjective(3) }, } ","keywords":"","version":"Next"}],"options":{"id":"default"}}